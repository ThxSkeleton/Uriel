
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

// ReSharper disable RedundantUsingDirective
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable JoinDeclarationAndInitializer

namespace OpenVX
{
	public partial class VX
	{
		public const uint VENDOR_MASK = 0xFFF00000;

		public const uint TYPE_MASK = 0x000FFF00;

		public const uint LIBRARY_MASK = 0x000FF000;

		public const uint KERNEL_MASK = 0x00000FFF;

		public const uint ATTRIBUTE_ID_MASK = 0x000000FF;

		public const uint ENUM_TYPE_MASK = 0x000FF000;

		public const uint ENUM_MASK = 0x00000FFF;

		public const string FMT_REF = "%I64u";

		public const string FMT_SIZE = "%I64u";

		public const uint SCALE_UNITY = 1024u;

		public const float SCALE_PYRAMID_HALF = 0.5f;

		public const float SCALE_PYRAMID_ORB = 0.8408964f;

		public const int TYPE_INVALID = 0x000;

		public const int TYPE_CHAR = 0x001;

		public const int TYPE_INT8 = 0x002;

		public const int TYPE_UINT8 = 0x003;

		public const int TYPE_INT16 = 0x004;

		public const int TYPE_UINT16 = 0x005;

		public const int TYPE_INT32 = 0x006;

		public const int TYPE_UINT32 = 0x007;

		public const int TYPE_INT64 = 0x008;

		public const int TYPE_UINT64 = 0x009;

		public const int TYPE_FLOAT32 = 0x00A;

		public const int TYPE_FLOAT64 = 0x00B;

		public const int TYPE_ENUM = 0x00C;

		public const int TYPE_SIZE = 0x00D;

		public const int TYPE_DF_IMAGE = 0x00E;

		public const int TYPE_FLOAT16 = 0x00F;

		public const int TYPE_BOOL = 0x010;

		public const int TYPE_RECTANGLE = 0x020;

		public const int TYPE_KEYPOINT = 0x021;

		public const int TYPE_COORDINATES2D = 0x022;

		public const int TYPE_COORDINATES3D = 0x023;

		public const int TYPE_COORDINATES2DF = 0x024;

		public const int TYPE_USER_STRUCT_START = 0x100;

		public const int TYPE_VENDOR_STRUCT_START = 0x400;

		public const int TYPE_KHRONOS_OBJECT_START = 0x800;

		public const int TYPE_VENDOR_OBJECT_START = 0xC00;

		public const int TYPE_KHRONOS_STRUCT_MAX = TYPE_USER_STRUCT_START - 1;

		public const int TYPE_USER_STRUCT_END = TYPE_VENDOR_STRUCT_START - 1;

		public const int TYPE_VENDOR_STRUCT_END = TYPE_KHRONOS_OBJECT_START - 1;

		public const int TYPE_KHRONOS_OBJECT_END = TYPE_VENDOR_OBJECT_START - 1;

		public const int TYPE_VENDOR_OBJECT_END = 0xFFF;

		public const int TYPE_REFERENCE = 0x800;

		public const int TYPE_CONTEXT = 0x801;

		public const int TYPE_GRAPH = 0x802;

		public const int TYPE_NODE = 0x803;

		public const int TYPE_KERNEL = 0x804;

		public const int TYPE_PARAMETER = 0x805;

		public const int TYPE_DELAY = 0x806;

		public const int TYPE_LUT = 0x807;

		public const int TYPE_DISTRIBUTION = 0x808;

		public const int TYPE_PYRAMID = 0x809;

		public const int TYPE_THRESHOLD = 0x80A;

		public const int TYPE_MATRIX = 0x80B;

		public const int TYPE_CONVOLUTION = 0x80C;

		public const int TYPE_SCALAR = 0x80D;

		public const int TYPE_ARRAY = 0x80E;

		public const int TYPE_IMAGE = 0x80F;

		public const int TYPE_REMAP = 0x810;

		public const int TYPE_ERROR = 0x811;

		public const int TYPE_META_FORMAT = 0x812;

		public const int TYPE_OBJECT_ARRAY = 0x813;

		public const int TYPE_TENSOR = 0x815;

		public const int STATUS_MIN = -25;

		public const int ERROR_REFERENCE_NONZERO = -24;

		public const int ERROR_MULTIPLE_WRITERS = -23;

		public const int ERROR_GRAPH_ABANDONED = -22;

		public const int ERROR_GRAPH_SCHEDULED = -21;

		public const int ERROR_INVALID_SCOPE = -20;

		public const int ERROR_INVALID_NODE = -19;

		public const int ERROR_INVALID_GRAPH = -18;

		public const int ERROR_INVALID_TYPE = -17;

		public const int ERROR_INVALID_VALUE = -16;

		public const int ERROR_INVALID_DIMENSION = -15;

		public const int ERROR_INVALID_FORMAT = -14;

		public const int ERROR_INVALID_LINK = -13;

		public const int ERROR_INVALID_REFERENCE = -12;

		public const int ERROR_INVALID_MODULE = -11;

		public const int ERROR_INVALID_PARAMETERS = -10;

		public const int ERROR_OPTIMIZED_AWAY = -9;

		public const int ERROR_NO_MEMORY = -8;

		public const int ERROR_NO_RESOURCES = -7;

		public const int ERROR_NOT_COMPATIBLE = -6;

		public const int ERROR_NOT_ALLOCATED = -5;

		public const int ERROR_NOT_SUFFICIENT = -4;

		public const int ERROR_NOT_SUPPORTED = -3;

		public const int ERROR_NOT_IMPLEMENTED = -2;

		public const int FAILURE = -1;

		public const int SUCCESS = 0;

		public const int ENUM_DIRECTION = 0x00;

		public const int ENUM_ACTION = 0x01;

		public const int ENUM_HINT = 0x02;

		public const int ENUM_DIRECTIVE = 0x03;

		public const int ENUM_INTERPOLATION = 0x04;

		public const int ENUM_OVERFLOW = 0x05;

		public const int ENUM_COLOR_SPACE = 0x06;

		public const int ENUM_COLOR_RANGE = 0x07;

		public const int ENUM_PARAMETER_STATE = 0x08;

		public const int ENUM_CHANNEL = 0x09;

		public const int ENUM_CONVERT_POLICY = 0x0A;

		public const int ENUM_THRESHOLD_TYPE = 0x0B;

		public const int ENUM_BORDER = 0x0C;

		public const int ENUM_COMPARISON = 0x0D;

		public const int ENUM_MEMORY_TYPE = 0x0E;

		public const int ENUM_TERM_CRITERIA = 0x0F;

		public const int ENUM_NORM_TYPE = 0x10;

		public const int ENUM_ACCESSOR = 0x11;

		public const int ENUM_ROUND_POLICY = 0x12;

		public const int ENUM_TARGET = 0x13;

		public const int ENUM_BORDER_POLICY = 0x14;

		public const int ENUM_GRAPH_STATE = 0x15;

		public const int ENUM_NONLINEAR = 0x16;

		public const int ENUM_PATTERN = 0x17;

		public const int ENUM_LBP_FORMAT = 0x18;

		public const int ENUM_COMP_METRIC = 0x19;

		public const int ACTION_CONTINUE = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x0;

		public const int ACTION_ABANDON = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x1;

		public const int INPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x0;

		public const int OUTPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x1;

		public const int BIDIRECTIONAL = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x2;

		public const int HINT_PERFORMANCE_DEFAULT = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x1;

		public const int HINT_PERFORMANCE_LOW_POWER = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x2;

		public const int HINT_PERFORMANCE_HIGH_SPEED = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x3;

		public const int DIRECTIVE_DISABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x0;

		public const int DIRECTIVE_ENABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x1;

		public const int DIRECTIVE_DISABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x2;

		public const int DIRECTIVE_ENABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x3;

		public const int GRAPH_STATE_UNVERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x0;

		public const int GRAPH_STATE_VERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x1;

		public const int GRAPH_STATE_RUNNING = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x2;

		public const int GRAPH_STATE_ABANDONED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x3;

		public const int GRAPH_STATE_COMPLETED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x4;

		public const int GRAPH_NUMNODES = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x0;

		public const int GRAPH_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x2;

		public const int GRAPH_NUMPARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x3;

		public const int GRAPH_STATE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x4;

		public const int CONVERT_POLICY_WRAP = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x0;

		public const int CONVERT_POLICY_SATURATE = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x1;

		public const int DF_IMAGE_VIRT = ((byte)'V') | ((byte)'I' << 8) | ((byte)'R' << 16) | ((byte)'T' << 24);

		public const int DF_IMAGE_RGB = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_RGBX = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'A' << 24);

		public const int DF_IMAGE_NV12 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'1' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_NV21 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'2' << 16) | ((byte)'1' << 24);

		public const int DF_IMAGE_UYVY = ((byte)'U') | ((byte)'Y' << 8) | ((byte)'V' << 16) | ((byte)'Y' << 24);

		public const int DF_IMAGE_YUYV = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'Y' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_IYUV = ((byte)'I') | ((byte)'Y' << 8) | ((byte)'U' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_YUV4 = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'V' << 16) | ((byte)'4' << 24);

		public const int DF_IMAGE_U8 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'0' << 16) | ((byte)'8' << 24);

		public const int DF_IMAGE_U16 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_S16 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_U32 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_S32 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int TARGET_ANY = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0000;

		public const int TARGET_STRING = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0001;

		public const int TARGET_VENDOR_BEGIN = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x1000;

		public const int REFERENCE_COUNT = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x0;

		public const int REFERENCE_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x1;

		public const int REFERENCE_NAME = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x2;

		public const int CONTEXT_VENDOR_ID = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x0;

		public const int CONTEXT_VERSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x1;

		public const int CONTEXT_UNIQUE_KERNELS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x2;

		public const int CONTEXT_MODULES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x3;

		public const int CONTEXT_REFERENCES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x4;

		public const int CONTEXT_IMPLEMENTATION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x5;

		public const int CONTEXT_EXTENSIONS_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x6;

		public const int CONTEXT_EXTENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x7;

		public const int CONTEXT_CONVOLUTION_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x8;

		public const int CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x9;

		public const int CONTEXT_IMMEDIATE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xA;

		public const int CONTEXT_UNIQUE_KERNEL_TABLE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xB;

		public const int CONTEXT_IMMEDIATE_BORDER_POLICY = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xC;

		public const int CONTEXT_NONLINEAR_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xd;

		public const int CONTEXT_MAX_TENSOR_DIMS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xE;

		public const int KERNEL_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x0;

		public const int KERNEL_NAME = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x1;

		public const int KERNEL_ENUM = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x2;

		public const int KERNEL_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x3;

		public const int NODE_STATUS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x0;

		public const int NODE_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x1;

		public const int NODE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x2;

		public const int NODE_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x3;

		public const int NODE_LOCAL_DATA_PTR = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x4;

		public const int NODE_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x5;

		public const int NODE_IS_REPLICATED = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x6;

		public const int NODE_REPLICATE_FLAGS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x7;

		public const int NODE_VALID_RECT_RESET = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x8;

		public const int PARAMETER_INDEX = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x0;

		public const int PARAMETER_DIRECTION = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x1;

		public const int PARAMETER_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x2;

		public const int PARAMETER_STATE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x3;

		public const int PARAMETER_REF = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x4;

		public const int IMAGE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x0;

		public const int IMAGE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x1;

		public const int IMAGE_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x2;

		public const int IMAGE_PLANES = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x3;

		public const int IMAGE_SPACE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x4;

		public const int IMAGE_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x5;

		public const int IMAGE_MEMORY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x7;

		public const int IMAGE_IS_UNIFORM = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x8;

		public const int IMAGE_UNIFORM_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x9;

		public const int SCALAR_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_SCALAR << 8)) + 0x0;

		public const int SCALAR_OP_AND = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x0;

		public const int SCALAR_OP_OR = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x1;

		public const int SCALAR_OP_XOR = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x2;

		public const int SCALAR_OP_NAND = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x3;

		public const int SCALAR_OP_EQUAL = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x4;

		public const int SCALAR_OP_NOTEQUAL = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x5;

		public const int SCALAR_OP_LESS = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x6;

		public const int SCALAR_OP_LESSEQ = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x7;

		public const int SCALAR_OP_GREATER = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x8;

		public const int SCALAR_OP_GREATEREQ = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x9;

		public const int SCALAR_OP_ADD = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xA;

		public const int SCALAR_OP_SUBTRACT = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xB;

		public const int SCALAR_OP_MULTIPLY = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xC;

		public const int SCALAR_OP_DIVIDE = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xD;

		public const int SCALAR_OP_MODULUS = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xE;

		public const int SCALAR_OP_MIN = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0xF;

		public const int SCALAR_OP_MAX = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x10;

		public const int LUT_TYPE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x0;

		public const int LUT_COUNT = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x1;

		public const int LUT_SIZE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x2;

		public const int LUT_OFFSET = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x3;

		public const int DISTRIBUTION_DIMENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x0;

		public const int DISTRIBUTION_OFFSET = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x1;

		public const int DISTRIBUTION_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x2;

		public const int DISTRIBUTION_BINS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x3;

		public const int DISTRIBUTION_WINDOW = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x4;

		public const int DISTRIBUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x5;

		public const int THRESHOLD_TYPE_BINARY = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x0;

		public const int THRESHOLD_TYPE_RANGE = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x1;

		public const int THRESHOLD_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x0;

		public const int THRESHOLD_INPUT_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x7;

		public const int THRESHOLD_OUTPUT_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x8;

		public const int MATRIX_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x0;

		public const int MATRIX_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x1;

		public const int MATRIX_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x2;

		public const int MATRIX_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x3;

		public const int MATRIX_ORIGIN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x4;

		public const int MATRIX_PATTERN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x5;

		public const int CONVOLUTION_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x0;

		public const int CONVOLUTION_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x1;

		public const int CONVOLUTION_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x2;

		public const int CONVOLUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x3;

		public const int PYRAMID_LEVELS = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x0;

		public const int PYRAMID_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x1;

		public const int PYRAMID_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x2;

		public const int PYRAMID_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x3;

		public const int PYRAMID_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x4;

		public const int REMAP_SOURCE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x0;

		public const int REMAP_SOURCE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x1;

		public const int REMAP_DESTINATION_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x2;

		public const int REMAP_DESTINATION_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x3;

		public const int ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x0;

		public const int ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x1;

		public const int ARRAY_CAPACITY = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x2;

		public const int ARRAY_ITEMSIZE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x3;

		public const int OBJECT_ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x0;

		public const int OBJECT_ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x1;

		public const int TENSOR_NUMBER_OF_DIMS = ((( ID_KHRONOS) << 20) | ( TYPE_TENSOR  << 8)) + 0x0;

		public const int TENSOR_DIMS = ((( ID_KHRONOS) << 20) | ( TYPE_TENSOR  << 8)) + 0x1;

		public const int TENSOR_DATA_TYPE = ((( ID_KHRONOS) << 20) | ( TYPE_TENSOR  << 8)) + 0x2;

		public const int TENSOR_FIXED_POINT_POSITION = (((ID_KHRONOS) << 20) | ( TYPE_TENSOR << 8)) + 0x3;

		public const int VALID_RECT_CALLBACK = (((ID_KHRONOS) << 20) | ( TYPE_META_FORMAT << 8)) + 0x1;

		public const int CHANNEL_0 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x0;

		public const int CHANNEL_1 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x1;

		public const int CHANNEL_2 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x2;

		public const int CHANNEL_3 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x3;

		public const int CHANNEL_R = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x10;

		public const int CHANNEL_G = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x11;

		public const int CHANNEL_B = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x12;

		public const int CHANNEL_A = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x13;

		public const int CHANNEL_Y = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x14;

		public const int CHANNEL_U = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x15;

		public const int CHANNEL_V = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x16;

		public const int MEMORY_TYPE_NONE = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x0;

		public const int MEMORY_TYPE_HOST = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x1;

		public const int INTERPOLATION_NEAREST_NEIGHBOR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x0;

		public const int INTERPOLATION_BILINEAR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x1;

		public const int INTERPOLATION_AREA = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x2;

		public const int NONLINEAR_FILTER_MEDIAN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x0;

		public const int NONLINEAR_FILTER_MIN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x1;

		public const int NONLINEAR_FILTER_MAX = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x2;

		public const int PATTERN_BOX = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x0;

		public const int PATTERN_CROSS = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x1;

		public const int PATTERN_DISK = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x2;

		public const int PATTERN_OTHER = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x3;

		public const int COLOR_SPACE_NONE = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x0;

		public const int COLOR_SPACE_BT601_525 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x1;

		public const int COLOR_SPACE_BT601_625 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x2;

		public const int COLOR_SPACE_BT709 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x3;

		public const int COLOR_SPACE_DEFAULT = COLOR_SPACE_BT709;

		public const int CHANNEL_RANGE_FULL = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x0;

		public const int CHANNEL_RANGE_RESTRICTED = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x1;

		public const int PARAMETER_STATE_REQUIRED = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x0;

		public const int PARAMETER_STATE_OPTIONAL = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x1;

		public const int BORDER_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x0;

		public const int BORDER_CONSTANT = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x1;

		public const int BORDER_REPLICATE = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x2;

		public const int BORDER_POLICY_DEFAULT_TO_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x0;

		public const int BORDER_POLICY_RETURN_ERROR = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x1;

		public const int TERM_CRITERIA_ITERATIONS = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x0;

		public const int TERM_CRITERIA_EPSILON = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x1;

		public const int TERM_CRITERIA_BOTH = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x2;

		public const int NORM_L1 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x0;

		public const int NORM_L2 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x1;

		public const int DELAY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x0;

		public const int DELAY_SLOTS = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x1;

		public const int READ_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x1;

		public const int WRITE_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x2;

		public const int READ_AND_WRITE = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x3;

		public const int ROUND_POLICY_TO_ZERO = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x1;

		public const int ROUND_POLICY_TO_NEAREST_EVEN = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x2;

		public const int LBP = (( ID_KHRONOS << 20) | ( ENUM_LBP_FORMAT  << 12)) + 0x0;

		public const int MLBP = (( ID_KHRONOS << 20) | ( ENUM_LBP_FORMAT  << 12)) + 0x1;

		public const int ULBP = (( ID_KHRONOS << 20) | ( ENUM_LBP_FORMAT  << 12)) + 0x2;

		public const int COMPARE_HAMMING = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x0;

		public const int COMPARE_L1 = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x1;

		public const int COMPARE_L2 = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x2;

		public const int COMPARE_CCORR = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x3;

		public const int COMPARE_L2_NORM = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x4;

		public const int COMPARE_CCORR_NORM = (( ID_KHRONOS << 20) | ( ENUM_COMP_METRIC  << 12)) + 0x5;

		public const int NOGAP_X = 1;

		public const int LIBRARY_KHR_BASE = 0x0;

		public const int KERNEL_COLOR_CONVERT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1;

		public const int KERNEL_CHANNEL_EXTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2;

		public const int KERNEL_CHANNEL_COMBINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3;

		public const int KERNEL_SOBEL_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x4;

		public const int KERNEL_MAGNITUDE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x5;

		public const int KERNEL_PHASE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x6;

		public const int KERNEL_SCALE_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x7;

		public const int KERNEL_TABLE_LOOKUP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x8;

		public const int KERNEL_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x9;

		public const int KERNEL_EQUALIZE_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xA;

		public const int KERNEL_ABSDIFF = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xB;

		public const int KERNEL_MEAN_STDDEV = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xC;

		public const int KERNEL_THRESHOLD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xD;

		public const int KERNEL_INTEGRAL_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xE;

		public const int KERNEL_DILATE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xF;

		public const int KERNEL_ERODE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x10;

		public const int KERNEL_MEDIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x11;

		public const int KERNEL_BOX_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x12;

		public const int KERNEL_GAUSSIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x13;

		public const int KERNEL_CUSTOM_CONVOLUTION = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x14;

		public const int KERNEL_GAUSSIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x15;

		public const int KERNEL_ACCUMULATE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x16;

		public const int KERNEL_ACCUMULATE_WEIGHTED = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x17;

		public const int KERNEL_ACCUMULATE_SQUARE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x18;

		public const int KERNEL_MINMAXLOC = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x19;

		public const int KERNEL_CONVERTDEPTH = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1A;

		public const int KERNEL_CANNY_EDGE_DETECTOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1B;

		public const int KERNEL_AND = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1C;

		public const int KERNEL_OR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1D;

		public const int KERNEL_XOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1E;

		public const int KERNEL_NOT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1F;

		public const int KERNEL_MULTIPLY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x20;

		public const int KERNEL_ADD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x21;

		public const int KERNEL_SUBTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x22;

		public const int KERNEL_WARP_AFFINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x23;

		public const int KERNEL_WARP_PERSPECTIVE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x24;

		public const int KERNEL_HARRIS_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x25;

		public const int KERNEL_FAST_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x26;

		public const int KERNEL_OPTICAL_FLOW_PYR_LK = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x27;

		public const int KERNEL_REMAP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x28;

		public const int KERNEL_HALFSCALE_GAUSSIAN = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x29;

		public const int KERNEL_LAPLACIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2A;

		public const int KERNEL_LAPLACIAN_RECONSTRUCT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2B;

		public const int KERNEL_NON_LINEAR_FILTER = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2C;

		public const int KERNEL_MATCH_TEMPLATE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2D;

		public const int KERNEL_LBP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2E;

		public const int KERNEL_HOUGH_LINES_P = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2F;

		public const int KERNEL_TENSOR_MULTIPLY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x30;

		public const int KERNEL_TENSOR_ADD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x31;

		public const int KERNEL_TENSOR_SUBTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x32;

		public const int KERNEL_TENSOR_TABLELOOKUP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x33;

		public const int KERNEL_TENSOR_TRANSPOSE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x34;

		public const int KERNEL_TENSOR_CONVERT_DEPTH = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x35;

		public const int KERNEL_TENSOR_MATRIX_MULTIPLY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x36;

		public const int KERNEL_COPY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x37;

		public const int KERNEL_NON_MAX_SUPPRESSION = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x38;

		public const int KERNEL_SCALAR_OPERATION = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x39;

		public const int KERNEL_HOG_FEATURES = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3A;

		public const int KERNEL_HOG_CELLS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3B;

		public const int KERNEL_BILATERAL_FILTER = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3C;

		public const int KERNEL_SELECT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3D;

		public const int ID_KHRONOS = 0x000;

		public const int ID_TI = 0x001;

		public const int ID_QUALCOMM = 0x002;

		public const int ID_NVIDIA = 0x003;

		public const int ID_ARM = 0x004;

		public const int ID_BDTI = 0x005;

		public const int ID_RENESAS = 0x006;

		public const int ID_VIVANTE = 0x007;

		public const int ID_XILINX = 0x008;

		public const int ID_AXIS = 0x009;

		public const int ID_MOVIDIUS = 0x00A;

		public const int ID_SAMSUNG = 0x00B;

		public const int ID_FREESCALE = 0x00C;

		public const int ID_AMD = 0x00D;

		public const int ID_BROADCOM = 0x00E;

		public const int ID_INTEL = 0x00F;

		public const int ID_MARVELL = 0x010;

		public const int ID_MEDIATEK = 0x011;

		public const int ID_ST = 0x012;

		public const int ID_CEVA = 0x013;

		public const int ID_ITSEEZ = 0x014;

		public const int ID_IMAGINATION = 0x015;

		public const int ID_NXP = 0x016;

		public const int ID_VIDEANTIS = 0x017;

		public const int ID_SYNOPSYS = 0x018;

		public const int ID_CADENCE = 0x019;

		public const int ID_HUAWEI = 0x01A;

		public const int ID_SOCIONEXT = 0x01B;

		public const int ID_USER = 0xFFE;

		public const int ID_MAX = 0xFFF;

		public const int ID_DEFAULT = ID_MAX;

		public const int ENUM_IX_USE = 0x18;

		public const int IX_USE_APPLICATION_CREATE = ((ID_KHRONOS << 20) | ( ENUM_IX_USE << 12)) + 0x0;

		public const int IX_USE_EXPORT_VALUES = ((ID_KHRONOS << 20) | ( ENUM_IX_USE << 12)) + 0x1;

		public const int IX_USE_NO_EXPORT_VALUES = ((ID_KHRONOS << 20) | ( ENUM_IX_USE << 12)) + 0x2;

		public const int TYPE_IMPORT = 0x814;

		public static Context CreateContext()
		{
			Context retValue;

			Debug.Assert(Delegates.pvxCreateContext != null, "pvxCreateContext not implemented");
			retValue = Delegates.pvxCreateContext();
			LogCommand("vxCreateContext", retValue			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Context context)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseContext != null, "pvxReleaseContext not implemented");
			retValue = Delegates.pvxReleaseContext(ref context);
			LogCommand("vxReleaseContext", retValue, context			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Context GetContext(Reference reference)
		{
			Context retValue;

			Debug.Assert(Delegates.pvxGetContext != null, "pvxGetContext not implemented");
			retValue = Delegates.pvxGetContext(reference);
			LogCommand("vxGetContext", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Context context, ContextAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryContext != null, "pvxQueryContext not implemented");
					retValue = Delegates.pvxQueryContext(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryContext", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Context context, ContextAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetContextAttribute != null, "pvxSetContextAttribute not implemented");
					retValue = Delegates.pvxSetContextAttribute(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetContextAttribute", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Hint(Reference reference, Hint hint, IntPtr data, UIntPtr data_size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxHint != null, "pvxHint not implemented");
					retValue = Delegates.pvxHint(reference, hint, data.ToPointer(), data_size);
					LogCommand("vxHint", retValue, reference, hint, data, data_size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Directive(Reference reference, Directive directive)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxDirective != null, "pvxDirective not implemented");
			retValue = Delegates.pvxDirective(reference, directive);
			LogCommand("vxDirective", retValue, reference, directive			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GetStatus(Reference reference)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxGetStatus != null, "pvxGetStatus not implemented");
			retValue = Delegates.pvxGetStatus(reference);
			LogCommand("vxGetStatus", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Type RegisterUserStruct(Context context, UIntPtr size)
		{
			Type retValue;

			Debug.Assert(Delegates.pvxRegisterUserStruct != null, "pvxRegisterUserStruct not implemented");
			retValue = Delegates.pvxRegisterUserStruct(context, size);
			LogCommand("vxRegisterUserStruct", retValue, context, size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AllocateUserKernelId(Context context, Type[] pKernelEnumId)
		{
			Status retValue;

			unsafe {
				fixed (Type* p_pKernelEnumId = pKernelEnumId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelId != null, "pvxAllocateUserKernelId not implemented");
					retValue = Delegates.pvxAllocateUserKernelId(context, p_pKernelEnumId);
					LogCommand("vxAllocateUserKernelId", retValue, context, pKernelEnumId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AllocateUserKernelLibraryId(Context context, int[] pLibraryId)
		{
			Status retValue;

			unsafe {
				fixed (int* p_pLibraryId = pLibraryId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelLibraryId != null, "pvxAllocateUserKernelLibraryId not implemented");
					retValue = Delegates.pvxAllocateUserKernelLibraryId(context, p_pLibraryId);
					LogCommand("vxAllocateUserKernelLibraryId", retValue, context, pLibraryId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImmediateModeTarget(Context context, Target target_enum, string target_string)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetImmediateModeTarget != null, "pvxSetImmediateModeTarget not implemented");
			retValue = Delegates.pvxSetImmediateModeTarget(context, target_enum, target_string);
			LogCommand("vxSetImmediateModeTarget", retValue, context, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImage(Context context, uint width, uint height, DfImage color)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateImage != null, "pvxCreateImage not implemented");
			retValue = Delegates.pvxCreateImage(context, width, height, color);
			LogCommand("vxCreateImage", retValue, context, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromROI(Image img, Rectangle[] rect)
		{
			Image retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxCreateImageFromROI != null, "pvxCreateImageFromROI not implemented");
					retValue = Delegates.pvxCreateImageFromROI(img, p_rect);
					LogCommand("vxCreateImageFromROI", retValue, img, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateUniformImage(Context context, uint width, uint height, DfImage color, PixelValue value)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateUniformImage != null, "pvxCreateUniformImage not implemented");
			retValue = Delegates.pvxCreateUniformImage(context, width, height, color, value);
			LogCommand("vxCreateUniformImage", retValue, context, width, height, color, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateVirtualImage(Graph graph, uint width, uint height, DfImage color)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateVirtualImage != null, "pvxCreateVirtualImage not implemented");
			retValue = Delegates.pvxCreateVirtualImage(graph, width, height, color);
			LogCommand("vxCreateVirtualImage", retValue, graph, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromHandle(Context context, DfImage color, ImagePatchAddressing[] addrs, IntPtr[] ptrs, MemoryType memory_type)
		{
			Image retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addrs = addrs)
				fixed (IntPtr* p_ptrs = ptrs)
				{
					Debug.Assert(Delegates.pvxCreateImageFromHandle != null, "pvxCreateImageFromHandle not implemented");
					retValue = Delegates.pvxCreateImageFromHandle(context, color, p_addrs, p_ptrs, memory_type);
					LogCommand("vxCreateImageFromHandle", retValue, context, color, addrs, ptrs, memory_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SwapImageHandle(Image image, IntPtr[] new_ptrs, IntPtr[] prev_ptrs, UIntPtr num_planes)
		{
			Status retValue;

			unsafe {
				fixed (IntPtr* p_new_ptrs = new_ptrs)
				fixed (IntPtr* p_prev_ptrs = prev_ptrs)
				{
					Debug.Assert(Delegates.pvxSwapImageHandle != null, "pvxSwapImageHandle not implemented");
					retValue = Delegates.pvxSwapImageHandle(image, p_new_ptrs, p_prev_ptrs, num_planes);
					LogCommand("vxSwapImageHandle", retValue, image, new_ptrs, prev_ptrs, num_planes					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Image image, ImageAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryImage != null, "pvxQueryImage not implemented");
					retValue = Delegates.pvxQueryImage(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryImage", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Image image, ImageAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetImageAttribute != null, "pvxSetImageAttribute not implemented");
					retValue = Delegates.pvxSetImageAttribute(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetImageAttribute", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImagePixelValues(Image image, PixelValue pixel_value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetImagePixelValues != null, "pvxSetImagePixelValues not implemented");
			retValue = Delegates.pvxSetImagePixelValues(image, pixel_value);
			LogCommand("vxSetImagePixelValues", retValue, image, pixel_value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Image image)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseImage != null, "pvxReleaseImage not implemented");
			retValue = Delegates.pvxReleaseImage(ref image);
			LogCommand("vxReleaseImage", retValue, image			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAddress1d(IntPtr ptr, uint index, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress1d != null, "pvxFormatImagePatchAddress1d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress1d(ptr.ToPointer(), index, p_addr);
					LogCommand("vxFormatImagePatchAddress1d", retValue, ptr, index, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAddress2d(IntPtr ptr, uint x, uint y, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress2d != null, "pvxFormatImagePatchAddress2d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress2d(ptr.ToPointer(), x, y, p_addr);
					LogCommand("vxFormatImagePatchAddress2d", retValue, ptr, x, y, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GetValidRegionImage(Image image, [Out] Rectangle[] rect)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxGetValidRegionImage != null, "pvxGetValidRegionImage not implemented");
					retValue = Delegates.pvxGetValidRegionImage(image, p_rect);
					LogCommand("vxGetValidRegionImage", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyImagePatch(Image image, ref Rectangle image_rect, uint image_plane_index, ref ImagePatchAddressing user_addr, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyImagePatch != null, "pvxCopyImagePatch not implemented");
					retValue = Delegates.pvxCopyImagePatch(image, ref image_rect, image_plane_index, ref user_addr, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyImagePatch", retValue, image, image_rect, image_plane_index, user_addr, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapImagePatch(Image image, Rectangle[] rect, uint plane_index, MapId[] map_id, ImagePatchAddressing[] addr, IntPtr[] ptr, Accessor usage, MemoryType mem_type, MapFlag flags)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				fixed (MapId* p_map_id = map_id)
				fixed (ImagePatchAddressing* p_addr = addr)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapImagePatch != null, "pvxMapImagePatch not implemented");
					retValue = Delegates.pvxMapImagePatch(image, p_rect, plane_index, p_map_id, p_addr, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapImagePatch", retValue, image, rect, plane_index, map_id, addr, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapImagePatch(Image image, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapImagePatch != null, "pvxUnmapImagePatch not implemented");
			retValue = Delegates.pvxUnmapImagePatch(image, map_id);
			LogCommand("vxUnmapImagePatch", retValue, image, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromChannel(Image img, Channel channel)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateImageFromChannel != null, "pvxCreateImageFromChannel not implemented");
			retValue = Delegates.pvxCreateImageFromChannel(img, channel);
			LogCommand("vxCreateImageFromChannel", retValue, img, channel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImageValidRectangle(Image image, Rectangle[] rect)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxSetImageValidRectangle != null, "pvxSetImageValidRectangle not implemented");
					retValue = Delegates.pvxSetImageValidRectangle(image, p_rect);
					LogCommand("vxSetImageValidRectangle", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status LoadKernels(Context context, string module)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxLoadKernels != null, "pvxLoadKernels not implemented");
			retValue = Delegates.pvxLoadKernels(context, module);
			LogCommand("vxLoadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnloadKernels(Context context, string module)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnloadKernels != null, "pvxUnloadKernels not implemented");
			retValue = Delegates.pvxUnloadKernels(context, module);
			LogCommand("vxUnloadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel GetKernelByName(Context context, string name)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxGetKernelByName != null, "pvxGetKernelByName not implemented");
			retValue = Delegates.pvxGetKernelByName(context, name);
			LogCommand("vxGetKernelByName", retValue, context, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel GetKernelByEnum(Context context, KernelType kernel)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxGetKernelByEnum != null, "pvxGetKernelByEnum not implemented");
			retValue = Delegates.pvxGetKernelByEnum(context, kernel);
			LogCommand("vxGetKernelByEnum", retValue, context, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Kernel kernel, KernelAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryKernel != null, "pvxQueryKernel not implemented");
					retValue = Delegates.pvxQueryKernel(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryKernel", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Kernel kernel)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseKernel != null, "pvxReleaseKernel not implemented");
			retValue = Delegates.pvxReleaseKernel(ref kernel);
			LogCommand("vxReleaseKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel AddUserKernel(Context context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxAddUserKernel != null, "pvxAddUserKernel not implemented");
			retValue = Delegates.pvxAddUserKernel(context, name, enumeration, func_ptr, numParams, validate, init, deinit);
			LogCommand("vxAddUserKernel", retValue, context, name, enumeration, func_ptr, numParams, validate, init, deinit			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status FinalizeKernel(Kernel kernel)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxFinalizeKernel != null, "pvxFinalizeKernel not implemented");
			retValue = Delegates.pvxFinalizeKernel(kernel);
			LogCommand("vxFinalizeKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddParameterToKernel(Kernel kernel, uint index, Direction dir, Type data_type, ParameterState state)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAddParameterToKernel != null, "pvxAddParameterToKernel not implemented");
			retValue = Delegates.pvxAddParameterToKernel(kernel, index, dir, data_type, state);
			LogCommand("vxAddParameterToKernel", retValue, kernel, index, dir, data_type, state			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RemoveKernel(Kernel kernel)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRemoveKernel != null, "pvxRemoveKernel not implemented");
			retValue = Delegates.pvxRemoveKernel(kernel);
			LogCommand("vxRemoveKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Kernel kernel, KernelAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetKernelAttribute != null, "pvxSetKernelAttribute not implemented");
					retValue = Delegates.pvxSetKernelAttribute(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetKernelAttribute", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetParameterByIndex(Kernel kernel, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetKernelParameterByIndex != null, "pvxGetKernelParameterByIndex not implemented");
			retValue = Delegates.pvxGetKernelParameterByIndex(kernel, index);
			LogCommand("vxGetKernelParameterByIndex", retValue, kernel, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Graph CreateGraph(Context context)
		{
			Graph retValue;

			Debug.Assert(Delegates.pvxCreateGraph != null, "pvxCreateGraph not implemented");
			retValue = Delegates.pvxCreateGraph(context);
			LogCommand("vxCreateGraph", retValue, context			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseGraph != null, "pvxReleaseGraph not implemented");
			retValue = Delegates.pvxReleaseGraph(ref graph);
			LogCommand("vxReleaseGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status VerifyGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxVerifyGraph != null, "pvxVerifyGraph not implemented");
			retValue = Delegates.pvxVerifyGraph(graph);
			LogCommand("vxVerifyGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ProcessGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxProcessGraph != null, "pvxProcessGraph not implemented");
			retValue = Delegates.pvxProcessGraph(graph);
			LogCommand("vxProcessGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ScheduleGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxScheduleGraph != null, "pvxScheduleGraph not implemented");
			retValue = Delegates.pvxScheduleGraph(graph);
			LogCommand("vxScheduleGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status WaitGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxWaitGraph != null, "pvxWaitGraph not implemented");
			retValue = Delegates.pvxWaitGraph(graph);
			LogCommand("vxWaitGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Graph graph, GraphAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryGraph != null, "pvxQueryGraph not implemented");
					retValue = Delegates.pvxQueryGraph(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryGraph", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Graph graph, GraphAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetGraphAttribute != null, "pvxSetGraphAttribute not implemented");
					retValue = Delegates.pvxSetGraphAttribute(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetGraphAttribute", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddParameterToGraph(Graph graph, Parameter parameter)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAddParameterToGraph != null, "pvxAddParameterToGraph not implemented");
			retValue = Delegates.pvxAddParameterToGraph(graph, parameter);
			LogCommand("vxAddParameterToGraph", retValue, graph, parameter			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetParameterByIndex(Graph graph, uint index, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetGraphParameterByIndex != null, "pvxSetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxSetGraphParameterByIndex(graph, index, value);
			LogCommand("vxSetGraphParameterByIndex", retValue, graph, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetParameterByIndex(Graph graph, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetGraphParameterByIndex != null, "pvxGetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxGetGraphParameterByIndex(graph, index);
			LogCommand("vxGetGraphParameterByIndex", retValue, graph, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static bool IsGraph(Graph graph)
		{
			bool retValue;

			Debug.Assert(Delegates.pvxIsGraphVerified != null, "pvxIsGraphVerified not implemented");
			retValue = Delegates.pvxIsGraphVerified(graph);
			LogCommand("vxIsGraphVerified", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node CreateGenericNode(Graph graph, Kernel kernel)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxCreateGenericNode != null, "pvxCreateGenericNode not implemented");
			retValue = Delegates.pvxCreateGenericNode(graph, kernel);
			LogCommand("vxCreateGenericNode", retValue, graph, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Node node, NodeAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryNode != null, "pvxQueryNode not implemented");
					retValue = Delegates.pvxQueryNode(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryNode", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Node node, NodeAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetNodeAttribute != null, "pvxSetNodeAttribute not implemented");
					retValue = Delegates.pvxSetNodeAttribute(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetNodeAttribute", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Node node)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseNode != null, "pvxReleaseNode not implemented");
			retValue = Delegates.pvxReleaseNode(ref node);
			LogCommand("vxReleaseNode", retValue, node			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RemoveNode(Node[] node)
		{
			Status retValue;

			unsafe {
				fixed (Node* p_node = node)
				{
					Debug.Assert(Delegates.pvxRemoveNode != null, "pvxRemoveNode not implemented");
					retValue = Delegates.pvxRemoveNode(p_node);
					LogCommand("vxRemoveNode", retValue, node					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AssignNodeCallback(Node node, NodeCompleteCallback callback)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAssignNodeCallback != null, "pvxAssignNodeCallback not implemented");
			retValue = Delegates.pvxAssignNodeCallback(node, callback);
			LogCommand("vxAssignNodeCallback", retValue, node, callback			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static NodeCompleteCallback RetrieveNodeCallback(Node node)
		{
			NodeCompleteCallback retValue;

			Debug.Assert(Delegates.pvxRetrieveNodeCallback != null, "pvxRetrieveNodeCallback not implemented");
			retValue = Delegates.pvxRetrieveNodeCallback(node);
			LogCommand("vxRetrieveNodeCallback", retValue, node			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetNodeTarget(Node node, Target target_enum, string target_string)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetNodeTarget != null, "pvxSetNodeTarget not implemented");
			retValue = Delegates.pvxSetNodeTarget(node, target_enum, target_string);
			LogCommand("vxSetNodeTarget", retValue, node, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReplicateNode(Graph graph, Node first_node, bool[] replicate, uint number_of_parameters)
		{
			Status retValue;

			unsafe {
				fixed (bool* p_replicate = replicate)
				{
					Debug.Assert(Delegates.pvxReplicateNode != null, "pvxReplicateNode not implemented");
					retValue = Delegates.pvxReplicateNode(graph, first_node, p_replicate, number_of_parameters);
					LogCommand("vxReplicateNode", retValue, graph, first_node, replicate, number_of_parameters					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetParameterByIndex(Node node, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetParameterByIndex != null, "pvxGetParameterByIndex not implemented");
			retValue = Delegates.pvxGetParameterByIndex(node, index);
			LogCommand("vxGetParameterByIndex", retValue, node, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Parameter param)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseParameter != null, "pvxReleaseParameter not implemented");
			retValue = Delegates.pvxReleaseParameter(ref param);
			LogCommand("vxReleaseParameter", retValue, param			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetParameterByIndex(Node node, uint index, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetParameterByIndex != null, "pvxSetParameterByIndex not implemented");
			retValue = Delegates.pvxSetParameterByIndex(node, index, value);
			LogCommand("vxSetParameterByIndex", retValue, node, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetParameterByReference(Parameter parameter, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetParameterByReference != null, "pvxSetParameterByReference not implemented");
			retValue = Delegates.pvxSetParameterByReference(parameter, value);
			LogCommand("vxSetParameterByReference", retValue, parameter, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Parameter parameter, ParameterAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryParameter != null, "pvxQueryParameter not implemented");
					retValue = Delegates.pvxQueryParameter(parameter, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryParameter", retValue, parameter, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Scalar CreateScalar(Context context, Type data_type, IntPtr ptr)
		{
			Scalar retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCreateScalar != null, "pvxCreateScalar not implemented");
					retValue = Delegates.pvxCreateScalar(context, data_type, ptr.ToPointer());
					LogCommand("vxCreateScalar", retValue, context, data_type, ptr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Scalar CreateScalarWithSize(Context context, Type data_type, IntPtr ptr, UIntPtr size)
		{
			Scalar retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCreateScalarWithSize != null, "pvxCreateScalarWithSize not implemented");
					retValue = Delegates.pvxCreateScalarWithSize(context, data_type, ptr.ToPointer(), size);
					LogCommand("vxCreateScalarWithSize", retValue, context, data_type, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Scalar CreateVirtualScalar(Graph graph, Type data_type)
		{
			Scalar retValue;

			Debug.Assert(Delegates.pvxCreateVirtualScalar != null, "pvxCreateVirtualScalar not implemented");
			retValue = Delegates.pvxCreateVirtualScalar(graph, data_type);
			LogCommand("vxCreateVirtualScalar", retValue, graph, data_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Scalar scalar)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseScalar != null, "pvxReleaseScalar not implemented");
			retValue = Delegates.pvxReleaseScalar(ref scalar);
			LogCommand("vxReleaseScalar", retValue, scalar			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Scalar scalar, ScalarAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryScalar != null, "pvxQueryScalar not implemented");
					retValue = Delegates.pvxQueryScalar(scalar, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryScalar", retValue, scalar, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyScalar(Scalar scalar, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyScalar != null, "pvxCopyScalar not implemented");
					retValue = Delegates.pvxCopyScalar(scalar, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyScalar", retValue, scalar, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Reference @ref, ReferenceAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryReference != null, "pvxQueryReference not implemented");
					retValue = Delegates.pvxQueryReference(@ref, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryReference", retValue, @ref, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Reference ref_ptr)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseReference != null, "pvxReleaseReference not implemented");
			retValue = Delegates.pvxReleaseReference(ref ref_ptr);
			LogCommand("vxReleaseReference", retValue, ref_ptr			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RetainReference(Reference @ref)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRetainReference != null, "pvxRetainReference not implemented");
			retValue = Delegates.pvxRetainReference(@ref);
			LogCommand("vxRetainReference", retValue, @ref			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetReferenceName(Reference @ref, string name)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetReferenceName != null, "pvxSetReferenceName not implemented");
			retValue = Delegates.pvxSetReferenceName(@ref, name);
			LogCommand("vxSetReferenceName", retValue, @ref, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Delay delay, DelayAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDelay != null, "pvxQueryDelay not implemented");
					retValue = Delegates.pvxQueryDelay(delay, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDelay", retValue, delay, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Delay delay)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseDelay != null, "pvxReleaseDelay not implemented");
			retValue = Delegates.pvxReleaseDelay(ref delay);
			LogCommand("vxReleaseDelay", retValue, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Delay CreateDelay(Context context, Reference exemplar, UIntPtr num_slots)
		{
			Delay retValue;

			Debug.Assert(Delegates.pvxCreateDelay != null, "pvxCreateDelay not implemented");
			retValue = Delegates.pvxCreateDelay(context, exemplar, num_slots);
			LogCommand("vxCreateDelay", retValue, context, exemplar, num_slots			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Reference GetReferenceFromDelay(Delay delay, int index)
		{
			Reference retValue;

			Debug.Assert(Delegates.pvxGetReferenceFromDelay != null, "pvxGetReferenceFromDelay not implemented");
			retValue = Delegates.pvxGetReferenceFromDelay(delay, index);
			LogCommand("vxGetReferenceFromDelay", retValue, delay, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AgeDelay(Delay delay)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAgeDelay != null, "pvxAgeDelay not implemented");
			retValue = Delegates.pvxAgeDelay(delay);
			LogCommand("vxAgeDelay", retValue, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RegisterAutoAging(Graph graph, Delay delay)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRegisterAutoAging != null, "pvxRegisterAutoAging not implemented");
			retValue = Delegates.pvxRegisterAutoAging(graph, delay);
			LogCommand("vxRegisterAutoAging", retValue, graph, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static void AddLogEntry(Reference @ref, Status status, string message, int vaArgs)
		{
			Debug.Assert(Delegates.pvxAddLogEntry != null, "pvxAddLogEntry not implemented");
			Delegates.pvxAddLogEntry(@ref, status, message, vaArgs);
			LogCommand("vxAddLogEntry", null, @ref, status, message, vaArgs			);
			DebugCheckErrors(null);
		}

		public static void RegisterLogCallback(Context context, LogCallback callback, bool reentrant)
		{
			Debug.Assert(Delegates.pvxRegisterLogCallback != null, "pvxRegisterLogCallback not implemented");
			Delegates.pvxRegisterLogCallback(context, callback, reentrant);
			LogCommand("vxRegisterLogCallback", null, context, callback, reentrant			);
			DebugCheckErrors(null);
		}

		public static Lut CreateLUT(Context context, Type data_type, UIntPtr count)
		{
			Lut retValue;

			Debug.Assert(Delegates.pvxCreateLUT != null, "pvxCreateLUT not implemented");
			retValue = Delegates.pvxCreateLUT(context, data_type, count);
			LogCommand("vxCreateLUT", retValue, context, data_type, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Lut CreateVirtualLUT(Graph graph, Type data_type, UIntPtr count)
		{
			Lut retValue;

			Debug.Assert(Delegates.pvxCreateVirtualLUT != null, "pvxCreateVirtualLUT not implemented");
			retValue = Delegates.pvxCreateVirtualLUT(graph, data_type, count);
			LogCommand("vxCreateVirtualLUT", retValue, graph, data_type, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Lut lut)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseLUT != null, "pvxReleaseLUT not implemented");
			retValue = Delegates.pvxReleaseLUT(ref lut);
			LogCommand("vxReleaseLUT", retValue, lut			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Lut lut, LutAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryLUT != null, "pvxQueryLUT not implemented");
					retValue = Delegates.pvxQueryLUT(lut, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryLUT", retValue, lut, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyLUT(Lut lut, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyLUT != null, "pvxCopyLUT not implemented");
					retValue = Delegates.pvxCopyLUT(lut, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyLUT", retValue, lut, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapLUT(Lut lut, MapId[] map_id, IntPtr[] ptr, Accessor usage, MemoryType mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (MapId* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapLUT != null, "pvxMapLUT not implemented");
					retValue = Delegates.pvxMapLUT(lut, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapLUT", retValue, lut, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapLUT(Lut lut, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapLUT != null, "pvxUnmapLUT not implemented");
			retValue = Delegates.pvxUnmapLUT(lut, map_id);
			LogCommand("vxUnmapLUT", retValue, lut, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Distribution CreateDistribution(Context context, UIntPtr numBins, int offset, uint range)
		{
			Distribution retValue;

			Debug.Assert(Delegates.pvxCreateDistribution != null, "pvxCreateDistribution not implemented");
			retValue = Delegates.pvxCreateDistribution(context, numBins, offset, range);
			LogCommand("vxCreateDistribution", retValue, context, numBins, offset, range			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Distribution CreateVirtualDistribution(Graph graph, UIntPtr numBins, int offset, uint range)
		{
			Distribution retValue;

			Debug.Assert(Delegates.pvxCreateVirtualDistribution != null, "pvxCreateVirtualDistribution not implemented");
			retValue = Delegates.pvxCreateVirtualDistribution(graph, numBins, offset, range);
			LogCommand("vxCreateVirtualDistribution", retValue, graph, numBins, offset, range			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Distribution distribution)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseDistribution != null, "pvxReleaseDistribution not implemented");
			retValue = Delegates.pvxReleaseDistribution(ref distribution);
			LogCommand("vxReleaseDistribution", retValue, distribution			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Distribution distribution, DistributionAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDistribution != null, "pvxQueryDistribution not implemented");
					retValue = Delegates.pvxQueryDistribution(distribution, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDistribution", retValue, distribution, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyDistribution(Distribution distribution, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyDistribution != null, "pvxCopyDistribution not implemented");
					retValue = Delegates.pvxCopyDistribution(distribution, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyDistribution", retValue, distribution, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapDistribution(Distribution distribution, MapId[] map_id, IntPtr[] ptr, Accessor usage, MemoryType mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (MapId* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapDistribution != null, "pvxMapDistribution not implemented");
					retValue = Delegates.pvxMapDistribution(distribution, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapDistribution", retValue, distribution, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapDistribution(Distribution distribution, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapDistribution != null, "pvxUnmapDistribution not implemented");
			retValue = Delegates.pvxUnmapDistribution(distribution, map_id);
			LogCommand("vxUnmapDistribution", retValue, distribution, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Threshold CreateThresholdForImage(Context context, int thresh_type, DfImage input_format, DfImage output_format)
		{
			Threshold retValue;

			Debug.Assert(Delegates.pvxCreateThresholdForImage != null, "pvxCreateThresholdForImage not implemented");
			retValue = Delegates.pvxCreateThresholdForImage(context, thresh_type, input_format, output_format);
			LogCommand("vxCreateThresholdForImage", retValue, context, thresh_type, input_format, output_format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Threshold CreateVirtualThresholdForImage(Graph graph, int thresh_type, DfImage input_format, DfImage output_format)
		{
			Threshold retValue;

			Debug.Assert(Delegates.pvxCreateVirtualThresholdForImage != null, "pvxCreateVirtualThresholdForImage not implemented");
			retValue = Delegates.pvxCreateVirtualThresholdForImage(graph, thresh_type, input_format, output_format);
			LogCommand("vxCreateVirtualThresholdForImage", retValue, graph, thresh_type, input_format, output_format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyThresholdValue(Threshold thresh, PixelValue value_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxCopyThresholdValue != null, "pvxCopyThresholdValue not implemented");
			retValue = Delegates.pvxCopyThresholdValue(thresh, value_ptr, usage, user_mem_type);
			LogCommand("vxCopyThresholdValue", retValue, thresh, value_ptr, usage, user_mem_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyThresholdRange(Threshold thresh, PixelValue lower_value_ptr, PixelValue upper_value_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxCopyThresholdRange != null, "pvxCopyThresholdRange not implemented");
			retValue = Delegates.pvxCopyThresholdRange(thresh, lower_value_ptr, upper_value_ptr, usage, user_mem_type);
			LogCommand("vxCopyThresholdRange", retValue, thresh, lower_value_ptr, upper_value_ptr, usage, user_mem_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyThresholdOutput(Threshold thresh, PixelValue true_value_ptr, PixelValue false_value_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxCopyThresholdOutput != null, "pvxCopyThresholdOutput not implemented");
			retValue = Delegates.pvxCopyThresholdOutput(thresh, true_value_ptr, false_value_ptr, usage, user_mem_type);
			LogCommand("vxCopyThresholdOutput", retValue, thresh, true_value_ptr, false_value_ptr, usage, user_mem_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Threshold thresh)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseThreshold != null, "pvxReleaseThreshold not implemented");
			retValue = Delegates.pvxReleaseThreshold(ref thresh);
			LogCommand("vxReleaseThreshold", retValue, thresh			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Threshold thresh, ThresholdAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetThresholdAttribute != null, "pvxSetThresholdAttribute not implemented");
					retValue = Delegates.pvxSetThresholdAttribute(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetThresholdAttribute", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Threshold thresh, ThresholdAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryThreshold != null, "pvxQueryThreshold not implemented");
					retValue = Delegates.pvxQueryThreshold(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryThreshold", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateMatrix(Context c, Type data_type, UIntPtr columns, UIntPtr rows)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateMatrix != null, "pvxCreateMatrix not implemented");
			retValue = Delegates.pvxCreateMatrix(c, data_type, columns, rows);
			LogCommand("vxCreateMatrix", retValue, c, data_type, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateVirtualMatrix(Graph graph, Type data_type, UIntPtr columns, UIntPtr rows)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateVirtualMatrix != null, "pvxCreateVirtualMatrix not implemented");
			retValue = Delegates.pvxCreateVirtualMatrix(graph, data_type, columns, rows);
			LogCommand("vxCreateVirtualMatrix", retValue, graph, data_type, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Matrix mat)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseMatrix != null, "pvxReleaseMatrix not implemented");
			retValue = Delegates.pvxReleaseMatrix(ref mat);
			LogCommand("vxReleaseMatrix", retValue, mat			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Matrix mat, MatrixAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryMatrix != null, "pvxQueryMatrix not implemented");
					retValue = Delegates.pvxQueryMatrix(mat, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryMatrix", retValue, mat, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyMatrix(Matrix matrix, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyMatrix != null, "pvxCopyMatrix not implemented");
					retValue = Delegates.pvxCopyMatrix(matrix, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyMatrix", retValue, matrix, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateMatrixFromPattern(Context context, MatrixAttribute pattern, UIntPtr columns, UIntPtr rows)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateMatrixFromPattern != null, "pvxCreateMatrixFromPattern not implemented");
			retValue = Delegates.pvxCreateMatrixFromPattern(context, pattern, columns, rows);
			LogCommand("vxCreateMatrixFromPattern", retValue, context, pattern, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateMatrixFromPatternAndOr(Context context, Pattern pattern, UIntPtr columns, UIntPtr rows, UIntPtr origin_col, UIntPtr origin_row)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateMatrixFromPatternAndOrigin != null, "pvxCreateMatrixFromPatternAndOrigin not implemented");
			retValue = Delegates.pvxCreateMatrixFromPatternAndOrigin(context, pattern, columns, rows, origin_col, origin_row);
			LogCommand("vxCreateMatrixFromPatternAndOrigin", retValue, context, pattern, columns, rows, origin_col, origin_row			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Convolution CreateConvolution(Context context, UIntPtr columns, UIntPtr rows)
		{
			Convolution retValue;

			Debug.Assert(Delegates.pvxCreateConvolution != null, "pvxCreateConvolution not implemented");
			retValue = Delegates.pvxCreateConvolution(context, columns, rows);
			LogCommand("vxCreateConvolution", retValue, context, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Convolution CreateVirtualConvolution(Graph graph, UIntPtr columns, UIntPtr rows)
		{
			Convolution retValue;

			Debug.Assert(Delegates.pvxCreateVirtualConvolution != null, "pvxCreateVirtualConvolution not implemented");
			retValue = Delegates.pvxCreateVirtualConvolution(graph, columns, rows);
			LogCommand("vxCreateVirtualConvolution", retValue, graph, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Convolution conv)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseConvolution != null, "pvxReleaseConvolution not implemented");
			retValue = Delegates.pvxReleaseConvolution(ref conv);
			LogCommand("vxReleaseConvolution", retValue, conv			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Convolution conv, ConvolutionAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryConvolution != null, "pvxQueryConvolution not implemented");
					retValue = Delegates.pvxQueryConvolution(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryConvolution", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(Convolution conv, ConvolutionAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetConvolutionAttribute != null, "pvxSetConvolutionAttribute not implemented");
					retValue = Delegates.pvxSetConvolutionAttribute(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetConvolutionAttribute", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyConvolutionCoefficients(Convolution conv, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyConvolutionCoefficients != null, "pvxCopyConvolutionCoefficients not implemented");
					retValue = Delegates.pvxCopyConvolutionCoefficients(conv, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyConvolutionCoefficients", retValue, conv, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Pyramid CreatePyramid(Context context, UIntPtr levels, float scale, uint width, uint height, DfImage format)
		{
			Pyramid retValue;

			Debug.Assert(Delegates.pvxCreatePyramid != null, "pvxCreatePyramid not implemented");
			retValue = Delegates.pvxCreatePyramid(context, levels, scale, width, height, format);
			LogCommand("vxCreatePyramid", retValue, context, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Pyramid CreateVirtualPyramid(Graph graph, UIntPtr levels, float scale, uint width, uint height, DfImage format)
		{
			Pyramid retValue;

			Debug.Assert(Delegates.pvxCreateVirtualPyramid != null, "pvxCreateVirtualPyramid not implemented");
			retValue = Delegates.pvxCreateVirtualPyramid(graph, levels, scale, width, height, format);
			LogCommand("vxCreateVirtualPyramid", retValue, graph, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Pyramid pyr)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleasePyramid != null, "pvxReleasePyramid not implemented");
			retValue = Delegates.pvxReleasePyramid(ref pyr);
			LogCommand("vxReleasePyramid", retValue, pyr			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Pyramid pyr, PyramidAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryPyramid != null, "pvxQueryPyramid not implemented");
					retValue = Delegates.pvxQueryPyramid(pyr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryPyramid", retValue, pyr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image GetPyramidLevel(Pyramid pyr, uint index)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxGetPyramidLevel != null, "pvxGetPyramidLevel not implemented");
			retValue = Delegates.pvxGetPyramidLevel(pyr, index);
			LogCommand("vxGetPyramidLevel", retValue, pyr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Remap CreateRemap(Context context, uint src_width, uint src_height, uint dst_width, uint dst_height)
		{
			Remap retValue;

			Debug.Assert(Delegates.pvxCreateRemap != null, "pvxCreateRemap not implemented");
			retValue = Delegates.pvxCreateRemap(context, src_width, src_height, dst_width, dst_height);
			LogCommand("vxCreateRemap", retValue, context, src_width, src_height, dst_width, dst_height			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Remap CreateVirtualRemap(Graph graph, uint src_width, uint src_height, uint dst_width, uint dst_height)
		{
			Remap retValue;

			Debug.Assert(Delegates.pvxCreateVirtualRemap != null, "pvxCreateVirtualRemap not implemented");
			retValue = Delegates.pvxCreateVirtualRemap(graph, src_width, src_height, dst_width, dst_height);
			LogCommand("vxCreateVirtualRemap", retValue, graph, src_width, src_height, dst_width, dst_height			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Remap table)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseRemap != null, "pvxReleaseRemap not implemented");
			retValue = Delegates.pvxReleaseRemap(ref table);
			LogCommand("vxReleaseRemap", retValue, table			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapRemapPatch(Remap remap, Rectangle[] rect, MapId[] map_id, UIntPtr[] stride_y, IntPtr[] ptr, Type coordinate_type, Accessor usage, MemoryType mem_type)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				fixed (MapId* p_map_id = map_id)
				fixed (UIntPtr* p_stride_y = stride_y)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapRemapPatch != null, "pvxMapRemapPatch not implemented");
					retValue = Delegates.pvxMapRemapPatch(remap, p_rect, p_map_id, p_stride_y, p_ptr, coordinate_type, usage, mem_type);
					LogCommand("vxMapRemapPatch", retValue, remap, rect, map_id, stride_y, ptr, coordinate_type, usage, mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapRemapPatch(Remap remap, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapRemapPatch != null, "pvxUnmapRemapPatch not implemented");
			retValue = Delegates.pvxUnmapRemapPatch(remap, map_id);
			LogCommand("vxUnmapRemapPatch", retValue, remap, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyRemapPatch(Remap remap, Rectangle[] rect, UIntPtr user_stride_y, IntPtr user_ptr, Type user_coordinate_type, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxCopyRemapPatch != null, "pvxCopyRemapPatch not implemented");
					retValue = Delegates.pvxCopyRemapPatch(remap, p_rect, user_stride_y, user_ptr.ToPointer(), user_coordinate_type, usage, user_mem_type);
					LogCommand("vxCopyRemapPatch", retValue, remap, rect, user_stride_y, user_ptr, user_coordinate_type, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Remap table, RemapAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryRemap != null, "pvxQueryRemap not implemented");
					retValue = Delegates.pvxQueryRemap(table, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryRemap", retValue, table, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Array CreateArray(Context context, Type item_type, UIntPtr capacity)
		{
			Array retValue;

			Debug.Assert(Delegates.pvxCreateArray != null, "pvxCreateArray not implemented");
			retValue = Delegates.pvxCreateArray(context, item_type, capacity);
			LogCommand("vxCreateArray", retValue, context, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Array CreateVirtualArray(Graph graph, Type item_type, UIntPtr capacity)
		{
			Array retValue;

			Debug.Assert(Delegates.pvxCreateVirtualArray != null, "pvxCreateVirtualArray not implemented");
			retValue = Delegates.pvxCreateVirtualArray(graph, item_type, capacity);
			LogCommand("vxCreateVirtualArray", retValue, graph, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Array arr)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseArray != null, "pvxReleaseArray not implemented");
			retValue = Delegates.pvxReleaseArray(ref arr);
			LogCommand("vxReleaseArray", retValue, arr			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Array arr, ArrayAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryArray != null, "pvxQueryArray not implemented");
					retValue = Delegates.pvxQueryArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddArrayItems(Array arr, UIntPtr count, IntPtr ptr, UIntPtr stride)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxAddArrayItems != null, "pvxAddArrayItems not implemented");
					retValue = Delegates.pvxAddArrayItems(arr, count, ptr.ToPointer(), stride);
					LogCommand("vxAddArrayItems", retValue, arr, count, ptr, stride					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TruncateArray(Array arr, UIntPtr new_num_items)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxTruncateArray != null, "pvxTruncateArray not implemented");
			retValue = Delegates.pvxTruncateArray(arr, new_num_items);
			LogCommand("vxTruncateArray", retValue, arr, new_num_items			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyArrayRange(Array array, UIntPtr range_start, UIntPtr range_end, UIntPtr user_stride, IntPtr user_ptr, Accessor usage, MemoryType user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyArrayRange != null, "pvxCopyArrayRange not implemented");
					retValue = Delegates.pvxCopyArrayRange(array, range_start, range_end, user_stride, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyArrayRange", retValue, array, range_start, range_end, user_stride, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapArrayRange(Array array, UIntPtr range_start, UIntPtr range_end, ref MapId map_id, ref UIntPtr stride, out IntPtr ptr, Accessor usage, MemoryType mem_type, uint flags)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxMapArrayRange != null, "pvxMapArrayRange not implemented");
			retValue = Delegates.pvxMapArrayRange(array, range_start, range_end, ref map_id, ref stride, out ptr, usage, mem_type, flags);
			LogCommand("vxMapArrayRange", retValue, array, range_start, range_end, map_id, stride, ptr, usage, mem_type, flags			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapArrayRange(Array array, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapArrayRange != null, "pvxUnmapArrayRange not implemented");
			retValue = Delegates.pvxUnmapArrayRange(array, map_id);
			LogCommand("vxUnmapArrayRange", retValue, array, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static ObjectArray CreateObjectArray(Context context, Reference exemplar, UIntPtr count)
		{
			ObjectArray retValue;

			Debug.Assert(Delegates.pvxCreateObjectArray != null, "pvxCreateObjectArray not implemented");
			retValue = Delegates.pvxCreateObjectArray(context, exemplar, count);
			LogCommand("vxCreateObjectArray", retValue, context, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static ObjectArray CreateVirtualObjectArray(Graph graph, Reference exemplar, UIntPtr count)
		{
			ObjectArray retValue;

			Debug.Assert(Delegates.pvxCreateVirtualObjectArray != null, "pvxCreateVirtualObjectArray not implemented");
			retValue = Delegates.pvxCreateVirtualObjectArray(graph, exemplar, count);
			LogCommand("vxCreateVirtualObjectArray", retValue, graph, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Reference GetObjectArrayItem(ObjectArray arr, uint index)
		{
			Reference retValue;

			Debug.Assert(Delegates.pvxGetObjectArrayItem != null, "pvxGetObjectArrayItem not implemented");
			retValue = Delegates.pvxGetObjectArrayItem(arr, index);
			LogCommand("vxGetObjectArrayItem", retValue, arr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref ObjectArray arr)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseObjectArray != null, "pvxReleaseObjectArray not implemented");
			retValue = Delegates.pvxReleaseObjectArray(ref arr);
			LogCommand("vxReleaseObjectArray", retValue, arr			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(ObjectArray arr, ObjectArrayAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryObjectArray != null, "pvxQueryObjectArray not implemented");
					retValue = Delegates.pvxQueryObjectArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryObjectArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetAttribute(MetaFormat meta, int attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetMetaFormatAttribute != null, "pvxSetMetaFormatAttribute not implemented");
					retValue = Delegates.pvxSetMetaFormatAttribute(meta, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetMetaFormatAttribute", retValue, meta, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetMetaFormatFromReference(MetaFormat meta, Reference exemplar)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetMetaFormatFromReference != null, "pvxSetMetaFormatFromReference not implemented");
			retValue = Delegates.pvxSetMetaFormatFromReference(meta, exemplar);
			LogCommand("vxSetMetaFormatFromReference", retValue, meta, exemplar			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Tensor CreateTensor(Context context, UIntPtr number_of_dims, UIntPtr[] dims, Type data_type, sbyte fixed_point_position)
		{
			Tensor retValue;

			unsafe {
				fixed (UIntPtr* p_dims = dims)
				{
					Debug.Assert(Delegates.pvxCreateTensor != null, "pvxCreateTensor not implemented");
					retValue = Delegates.pvxCreateTensor(context, number_of_dims, p_dims, data_type, fixed_point_position);
					LogCommand("vxCreateTensor", retValue, context, number_of_dims, dims, data_type, fixed_point_position					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static ObjectArray CreateImageObjectArrayFromTensor(Tensor tensor, Rectangle[] rect, UIntPtr array_size, UIntPtr jump, DfImage image_format)
		{
			ObjectArray retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxCreateImageObjectArrayFromTensor != null, "pvxCreateImageObjectArrayFromTensor not implemented");
					retValue = Delegates.pvxCreateImageObjectArrayFromTensor(tensor, p_rect, array_size, jump, image_format);
					LogCommand("vxCreateImageObjectArrayFromTensor", retValue, tensor, rect, array_size, jump, image_format					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Tensor CreateTensorFrom(Tensor tensor, UIntPtr number_of_dims, UIntPtr[] view_start, UIntPtr[] view_end)
		{
			Tensor retValue;

			unsafe {
				fixed (UIntPtr* p_view_start = view_start)
				fixed (UIntPtr* p_view_end = view_end)
				{
					Debug.Assert(Delegates.pvxCreateTensorFromView != null, "pvxCreateTensorFromView not implemented");
					retValue = Delegates.pvxCreateTensorFromView(tensor, number_of_dims, p_view_start, p_view_end);
					LogCommand("vxCreateTensorFromView", retValue, tensor, number_of_dims, view_start, view_end					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Tensor CreateVirtualTensor(Graph graph, UIntPtr number_of_dims, UIntPtr[] dims, Type data_type, sbyte fixed_point_position)
		{
			Tensor retValue;

			unsafe {
				fixed (UIntPtr* p_dims = dims)
				{
					Debug.Assert(Delegates.pvxCreateVirtualTensor != null, "pvxCreateVirtualTensor not implemented");
					retValue = Delegates.pvxCreateVirtualTensor(graph, number_of_dims, p_dims, data_type, fixed_point_position);
					LogCommand("vxCreateVirtualTensor", retValue, graph, number_of_dims, dims, data_type, fixed_point_position					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyTensorPatch(Tensor tensor, UIntPtr number_of_dims, UIntPtr[] view_start, UIntPtr[] view_end, UIntPtr[] user_stride, IntPtr user_ptr, Accessor usage, MemoryType user_memory_type)
		{
			Status retValue;

			unsafe {
				fixed (UIntPtr* p_view_start = view_start)
				fixed (UIntPtr* p_view_end = view_end)
				fixed (UIntPtr* p_user_stride = user_stride)
				{
					Debug.Assert(Delegates.pvxCopyTensorPatch != null, "pvxCopyTensorPatch not implemented");
					retValue = Delegates.pvxCopyTensorPatch(tensor, number_of_dims, p_view_start, p_view_end, p_user_stride, user_ptr.ToPointer(), usage, user_memory_type);
					LogCommand("vxCopyTensorPatch", retValue, tensor, number_of_dims, view_start, view_end, user_stride, user_ptr, usage, user_memory_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Query(Tensor tensor, TensorAttribute attribute, IntPtr ptr, UIntPtr size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryTensor != null, "pvxQueryTensor not implemented");
					retValue = Delegates.pvxQueryTensor(tensor, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryTensor", retValue, tensor, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Tensor tensor)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseTensor != null, "pvxReleaseTensor not implemented");
			retValue = Delegates.pvxReleaseTensor(ref tensor);
			LogCommand("vxReleaseTensor", retValue, tensor			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ColorConvertNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxColorConvertNode != null, "pvxColorConvertNode not implemented");
			retValue = Delegates.pvxColorConvertNode(graph, input, output);
			LogCommand("vxColorConvertNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ChannelExtractNode(Graph graph, Image input, Channel channel, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxChannelExtractNode != null, "pvxChannelExtractNode not implemented");
			retValue = Delegates.pvxChannelExtractNode(graph, input, channel, output);
			LogCommand("vxChannelExtractNode", retValue, graph, input, channel, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ChannelCombineNode(Graph graph, Image plane0, Image plane1, Image plane2, Image plane3, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxChannelCombineNode != null, "pvxChannelCombineNode not implemented");
			retValue = Delegates.pvxChannelCombineNode(graph, plane0, plane1, plane2, plane3, output);
			LogCommand("vxChannelCombineNode", retValue, graph, plane0, plane1, plane2, plane3, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node PhaseNode(Graph graph, Image grad_x, Image grad_y, Image orientation)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxPhaseNode != null, "pvxPhaseNode not implemented");
			retValue = Delegates.pvxPhaseNode(graph, grad_x, grad_y, orientation);
			LogCommand("vxPhaseNode", retValue, graph, grad_x, grad_y, orientation			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Sobel3x3Node(Graph graph, Image input, Image output_x, Image output_y)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxSobel3x3Node != null, "pvxSobel3x3Node not implemented");
			retValue = Delegates.pvxSobel3x3Node(graph, input, output_x, output_y);
			LogCommand("vxSobel3x3Node", retValue, graph, input, output_x, output_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MagnitudeNode(Graph graph, Image grad_x, Image grad_y, Image mag)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMagnitudeNode != null, "pvxMagnitudeNode not implemented");
			retValue = Delegates.pvxMagnitudeNode(graph, grad_x, grad_y, mag);
			LogCommand("vxMagnitudeNode", retValue, graph, grad_x, grad_y, mag			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ScaleImageNode(Graph graph, Image src, Image dst, InterpolationType type)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxScaleImageNode != null, "pvxScaleImageNode not implemented");
			retValue = Delegates.pvxScaleImageNode(graph, src, dst, type);
			LogCommand("vxScaleImageNode", retValue, graph, src, dst, type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TableLookupNode(Graph graph, Image input, Lut lut, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTableLookupNode != null, "pvxTableLookupNode not implemented");
			retValue = Delegates.pvxTableLookupNode(graph, input, lut, output);
			LogCommand("vxTableLookupNode", retValue, graph, input, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HistogramNode(Graph graph, Image input, Distribution distribution)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHistogramNode != null, "pvxHistogramNode not implemented");
			retValue = Delegates.pvxHistogramNode(graph, input, distribution);
			LogCommand("vxHistogramNode", retValue, graph, input, distribution			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node EqualizeHistNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxEqualizeHistNode != null, "pvxEqualizeHistNode not implemented");
			retValue = Delegates.pvxEqualizeHistNode(graph, input, output);
			LogCommand("vxEqualizeHistNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AbsDiffNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAbsDiffNode != null, "pvxAbsDiffNode not implemented");
			retValue = Delegates.pvxAbsDiffNode(graph, in1, in2, @out);
			LogCommand("vxAbsDiffNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MeanStdDevNode(Graph graph, Image input, Scalar mean, Scalar stddev)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMeanStdDevNode != null, "pvxMeanStdDevNode not implemented");
			retValue = Delegates.pvxMeanStdDevNode(graph, input, mean, stddev);
			LogCommand("vxMeanStdDevNode", retValue, graph, input, mean, stddev			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ThresholdNode(Graph graph, Image input, Threshold thresh, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxThresholdNode != null, "pvxThresholdNode not implemented");
			retValue = Delegates.pvxThresholdNode(graph, input, thresh, output);
			LogCommand("vxThresholdNode", retValue, graph, input, thresh, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node NonMaxSuppressionNode(Graph graph, Image input, Image mask, int win_size, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxNonMaxSuppressionNode != null, "pvxNonMaxSuppressionNode not implemented");
			retValue = Delegates.pvxNonMaxSuppressionNode(graph, input, mask, win_size, output);
			LogCommand("vxNonMaxSuppressionNode", retValue, graph, input, mask, win_size, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node IntegralImageNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxIntegralImageNode != null, "pvxIntegralImageNode not implemented");
			retValue = Delegates.pvxIntegralImageNode(graph, input, output);
			LogCommand("vxIntegralImageNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Erode3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxErode3x3Node != null, "pvxErode3x3Node not implemented");
			retValue = Delegates.pvxErode3x3Node(graph, input, output);
			LogCommand("vxErode3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Dilate3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxDilate3x3Node != null, "pvxDilate3x3Node not implemented");
			retValue = Delegates.pvxDilate3x3Node(graph, input, output);
			LogCommand("vxDilate3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Median3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMedian3x3Node != null, "pvxMedian3x3Node not implemented");
			retValue = Delegates.pvxMedian3x3Node(graph, input, output);
			LogCommand("vxMedian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Box3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxBox3x3Node != null, "pvxBox3x3Node not implemented");
			retValue = Delegates.pvxBox3x3Node(graph, input, output);
			LogCommand("vxBox3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Gaussian3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxGaussian3x3Node != null, "pvxGaussian3x3Node not implemented");
			retValue = Delegates.pvxGaussian3x3Node(graph, input, output);
			LogCommand("vxGaussian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node NonLinearFilterNode(Graph graph, NonLinearFilter function, Image input, Matrix mask, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxNonLinearFilterNode != null, "pvxNonLinearFilterNode not implemented");
			retValue = Delegates.pvxNonLinearFilterNode(graph, function, input, mask, output);
			LogCommand("vxNonLinearFilterNode", retValue, graph, function, input, mask, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ConvolveNode(Graph graph, Image input, Convolution conv, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxConvolveNode != null, "pvxConvolveNode not implemented");
			retValue = Delegates.pvxConvolveNode(graph, input, conv, output);
			LogCommand("vxConvolveNode", retValue, graph, input, conv, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node GaussianPyramidNode(Graph graph, Image input, Pyramid gaussian)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxGaussianPyramidNode != null, "pvxGaussianPyramidNode not implemented");
			retValue = Delegates.pvxGaussianPyramidNode(graph, input, gaussian);
			LogCommand("vxGaussianPyramidNode", retValue, graph, input, gaussian			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node LaplacianPyramidNode(Graph graph, Image input, Pyramid laplacian, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxLaplacianPyramidNode != null, "pvxLaplacianPyramidNode not implemented");
			retValue = Delegates.pvxLaplacianPyramidNode(graph, input, laplacian, output);
			LogCommand("vxLaplacianPyramidNode", retValue, graph, input, laplacian, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node LaplacianReconstructNode(Graph graph, Pyramid laplacian, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxLaplacianReconstructNode != null, "pvxLaplacianReconstructNode not implemented");
			retValue = Delegates.pvxLaplacianReconstructNode(graph, laplacian, input, output);
			LogCommand("vxLaplacianReconstructNode", retValue, graph, laplacian, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateImageNode(Graph graph, Image input, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateImageNode != null, "pvxAccumulateImageNode not implemented");
			retValue = Delegates.pvxAccumulateImageNode(graph, input, accum);
			LogCommand("vxAccumulateImageNode", retValue, graph, input, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateWeightedImageNode(Graph graph, Image input, Scalar alpha, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateWeightedImageNode != null, "pvxAccumulateWeightedImageNode not implemented");
			retValue = Delegates.pvxAccumulateWeightedImageNode(graph, input, alpha, accum);
			LogCommand("vxAccumulateWeightedImageNode", retValue, graph, input, alpha, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateSquareImageNode(Graph graph, Image input, Scalar shift, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateSquareImageNode != null, "pvxAccumulateSquareImageNode not implemented");
			retValue = Delegates.pvxAccumulateSquareImageNode(graph, input, shift, accum);
			LogCommand("vxAccumulateSquareImageNode", retValue, graph, input, shift, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MinMaxLocNode(Graph graph, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMinMaxLocNode != null, "pvxMinMaxLocNode not implemented");
			retValue = Delegates.pvxMinMaxLocNode(graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount);
			LogCommand("vxMinMaxLocNode", retValue, graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MinNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMinNode != null, "pvxMinNode not implemented");
			retValue = Delegates.pvxMinNode(graph, in1, in2, @out);
			LogCommand("vxMinNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MaxNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMaxNode != null, "pvxMaxNode not implemented");
			retValue = Delegates.pvxMaxNode(graph, in1, in2, @out);
			LogCommand("vxMaxNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AndNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAndNode != null, "pvxAndNode not implemented");
			retValue = Delegates.pvxAndNode(graph, in1, in2, @out);
			LogCommand("vxAndNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node OrNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxOrNode != null, "pvxOrNode not implemented");
			retValue = Delegates.pvxOrNode(graph, in1, in2, @out);
			LogCommand("vxOrNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node XorNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxXorNode != null, "pvxXorNode not implemented");
			retValue = Delegates.pvxXorNode(graph, in1, in2, @out);
			LogCommand("vxXorNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node NotNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxNotNode != null, "pvxNotNode not implemented");
			retValue = Delegates.pvxNotNode(graph, input, output);
			LogCommand("vxNotNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ScalarOperationNode(Graph graph, ScalarOperation scalar_operation, Scalar a, Scalar b, Scalar output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxScalarOperationNode != null, "pvxScalarOperationNode not implemented");
			retValue = Delegates.pvxScalarOperationNode(graph, scalar_operation, a, b, output);
			LogCommand("vxScalarOperationNode", retValue, graph, scalar_operation, a, b, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node SelectNode(Graph graph, Scalar condition, Reference true_value, Reference false_value, Reference output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxSelectNode != null, "pvxSelectNode not implemented");
			retValue = Delegates.pvxSelectNode(graph, condition, true_value, false_value, output);
			LogCommand("vxSelectNode", retValue, graph, condition, true_value, false_value, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MultiplyNode(Graph graph, Image in1, Image in2, Scalar scale, ConvertPolicy overflow_policy, RoundPolicy rounding_policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMultiplyNode != null, "pvxMultiplyNode not implemented");
			retValue = Delegates.pvxMultiplyNode(graph, in1, in2, scale, overflow_policy, rounding_policy, @out);
			LogCommand("vxMultiplyNode", retValue, graph, in1, in2, scale, overflow_policy, rounding_policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AddNode(Graph graph, Image in1, Image in2, ConvertPolicy policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAddNode != null, "pvxAddNode not implemented");
			retValue = Delegates.pvxAddNode(graph, in1, in2, policy, @out);
			LogCommand("vxAddNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node SubtractNode(Graph graph, Image in1, Image in2, ConvertPolicy policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxSubtractNode != null, "pvxSubtractNode not implemented");
			retValue = Delegates.pvxSubtractNode(graph, in1, in2, policy, @out);
			LogCommand("vxSubtractNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ConvertDepthNode(Graph graph, Image input, Image output, ConvertPolicy policy, Scalar shift)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxConvertDepthNode != null, "pvxConvertDepthNode not implemented");
			retValue = Delegates.pvxConvertDepthNode(graph, input, output, policy, shift);
			LogCommand("vxConvertDepthNode", retValue, graph, input, output, policy, shift			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node CannyEdgeDetectorNode(Graph graph, Image input, Threshold hyst, int gradient_size, NormType norm_type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxCannyEdgeDetectorNode != null, "pvxCannyEdgeDetectorNode not implemented");
			retValue = Delegates.pvxCannyEdgeDetectorNode(graph, input, hyst, gradient_size, norm_type, output);
			LogCommand("vxCannyEdgeDetectorNode", retValue, graph, input, hyst, gradient_size, norm_type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node WarpAffineNode(Graph graph, Image input, Matrix matrix, InterpolationType type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxWarpAffineNode != null, "pvxWarpAffineNode not implemented");
			retValue = Delegates.pvxWarpAffineNode(graph, input, matrix, type, output);
			LogCommand("vxWarpAffineNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node WarpPerspectiveNode(Graph graph, Image input, Matrix matrix, InterpolationType type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxWarpPerspectiveNode != null, "pvxWarpPerspectiveNode not implemented");
			retValue = Delegates.pvxWarpPerspectiveNode(graph, input, matrix, type, output);
			LogCommand("vxWarpPerspectiveNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HarrisCornersNode(Graph graph, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHarrisCornersNode != null, "pvxHarrisCornersNode not implemented");
			retValue = Delegates.pvxHarrisCornersNode(graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners);
			LogCommand("vxHarrisCornersNode", retValue, graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node FastCornersNode(Graph graph, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxFastCornersNode != null, "pvxFastCornersNode not implemented");
			retValue = Delegates.pvxFastCornersNode(graph, input, strength_thresh, nonmax_suppression, corners, num_corners);
			LogCommand("vxFastCornersNode", retValue, graph, input, strength_thresh, nonmax_suppression, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node OpticalFlowPyrLKNode(Graph graph, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, TerminationCriteria termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, UIntPtr window_dimension)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxOpticalFlowPyrLKNode != null, "pvxOpticalFlowPyrLKNode not implemented");
			retValue = Delegates.pvxOpticalFlowPyrLKNode(graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension);
			LogCommand("vxOpticalFlowPyrLKNode", retValue, graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node RemapNode(Graph graph, Image input, Remap table, InterpolationType policy, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxRemapNode != null, "pvxRemapNode not implemented");
			retValue = Delegates.pvxRemapNode(graph, input, table, policy, output);
			LogCommand("vxRemapNode", retValue, graph, input, table, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HalfScaleGaussianNode(Graph graph, Image input, Image output, int kernel_size)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHalfScaleGaussianNode != null, "pvxHalfScaleGaussianNode not implemented");
			retValue = Delegates.pvxHalfScaleGaussianNode(graph, input, output, kernel_size);
			LogCommand("vxHalfScaleGaussianNode", retValue, graph, input, output, kernel_size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MatchTemplateNode(Graph graph, Image src, Image templateImage, CompareMetric matchingMethod, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMatchTemplateNode != null, "pvxMatchTemplateNode not implemented");
			retValue = Delegates.pvxMatchTemplateNode(graph, src, templateImage, matchingMethod, output);
			LogCommand("vxMatchTemplateNode", retValue, graph, src, templateImage, matchingMethod, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node LBPNode(Graph graph, Image @in, LbpFormat format, sbyte kernel_size, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxLBPNode != null, "pvxLBPNode not implemented");
			retValue = Delegates.pvxLBPNode(graph, @in, format, kernel_size, @out);
			LogCommand("vxLBPNode", retValue, graph, @in, format, kernel_size, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HOGFeaturesNode(Graph graph, Image input, Tensor magnitudes, Tensor bins, Hog[] @params, UIntPtr hog_param_size, Tensor features)
		{
			Node retValue;

			unsafe {
				fixed (Hog* p_params = @params)
				{
					Debug.Assert(Delegates.pvxHOGFeaturesNode != null, "pvxHOGFeaturesNode not implemented");
					retValue = Delegates.pvxHOGFeaturesNode(graph, input, magnitudes, bins, p_params, hog_param_size, features);
					LogCommand("vxHOGFeaturesNode", retValue, graph, input, magnitudes, bins, @params, hog_param_size, features					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HOGCellsNode(Graph graph, Image input, int cell_width, int cell_height, int num_bins, Tensor magnitudes, Tensor bins)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHOGCellsNode != null, "pvxHOGCellsNode not implemented");
			retValue = Delegates.pvxHOGCellsNode(graph, input, cell_width, cell_height, num_bins, magnitudes, bins);
			LogCommand("vxHOGCellsNode", retValue, graph, input, cell_width, cell_height, num_bins, magnitudes, bins			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HoughLinesPNode(Graph graph, Image input, HoughLinesParams[] @params, Array lines_array, Scalar num_lines)
		{
			Node retValue;

			unsafe {
				fixed (HoughLinesParams* p_params = @params)
				{
					Debug.Assert(Delegates.pvxHoughLinesPNode != null, "pvxHoughLinesPNode not implemented");
					retValue = Delegates.pvxHoughLinesPNode(graph, input, p_params, lines_array, num_lines);
					LogCommand("vxHoughLinesPNode", retValue, graph, input, @params, lines_array, num_lines					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node BilateralFilterNode(Graph graph, Tensor src, int diameter, float sigmaSpace, float sigmaValues, Tensor dst)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxBilateralFilterNode != null, "pvxBilateralFilterNode not implemented");
			retValue = Delegates.pvxBilateralFilterNode(graph, src, diameter, sigmaSpace, sigmaValues, dst);
			LogCommand("vxBilateralFilterNode", retValue, graph, src, diameter, sigmaSpace, sigmaValues, dst			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorMultiplyNode(Graph graph, Tensor input1, Tensor input2, Scalar scale, ConvertPolicy overflow_policy, RoundPolicy rounding_policy, Tensor output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorMultiplyNode != null, "pvxTensorMultiplyNode not implemented");
			retValue = Delegates.pvxTensorMultiplyNode(graph, input1, input2, scale, overflow_policy, rounding_policy, output);
			LogCommand("vxTensorMultiplyNode", retValue, graph, input1, input2, scale, overflow_policy, rounding_policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorAddNode(Graph graph, Tensor input1, Tensor input2, ConvertPolicy policy, Tensor output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorAddNode != null, "pvxTensorAddNode not implemented");
			retValue = Delegates.pvxTensorAddNode(graph, input1, input2, policy, output);
			LogCommand("vxTensorAddNode", retValue, graph, input1, input2, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorSubtractNode(Graph graph, Tensor input1, Tensor input2, ConvertPolicy policy, Tensor output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorSubtractNode != null, "pvxTensorSubtractNode not implemented");
			retValue = Delegates.pvxTensorSubtractNode(graph, input1, input2, policy, output);
			LogCommand("vxTensorSubtractNode", retValue, graph, input1, input2, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorTableLookupNode(Graph graph, Tensor input1, Lut lut, Tensor output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorTableLookupNode != null, "pvxTensorTableLookupNode not implemented");
			retValue = Delegates.pvxTensorTableLookupNode(graph, input1, lut, output);
			LogCommand("vxTensorTableLookupNode", retValue, graph, input1, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorTransposeNode(Graph graph, Tensor input, Tensor output, UIntPtr dimension1, UIntPtr dimension2)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorTransposeNode != null, "pvxTensorTransposeNode not implemented");
			retValue = Delegates.pvxTensorTransposeNode(graph, input, output, dimension1, dimension2);
			LogCommand("vxTensorTransposeNode", retValue, graph, input, output, dimension1, dimension2			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TensorConvertDepthNode(Graph graph, Tensor input, ConvertPolicy policy, Scalar norm, Scalar offset, Tensor output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTensorConvertDepthNode != null, "pvxTensorConvertDepthNode not implemented");
			retValue = Delegates.pvxTensorConvertDepthNode(graph, input, policy, norm, offset, output);
			LogCommand("vxTensorConvertDepthNode", retValue, graph, input, policy, norm, offset, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MatrixMultiplyNode(Graph graph, Tensor input1, Tensor input2, Tensor input3, MatrixMulParams[] matrix_multiply_params, Tensor output)
		{
			Node retValue;

			unsafe {
				fixed (MatrixMulParams* p_matrix_multiply_params = matrix_multiply_params)
				{
					Debug.Assert(Delegates.pvxMatrixMultiplyNode != null, "pvxMatrixMultiplyNode not implemented");
					retValue = Delegates.pvxMatrixMultiplyNode(graph, input1, input2, input3, p_matrix_multiply_params, output);
					LogCommand("vxMatrixMultiplyNode", retValue, graph, input1, input2, input3, matrix_multiply_params, output					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node CopyNode(Graph graph, Reference input, Reference output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxCopyNode != null, "pvxCopyNode not implemented");
			retValue = Delegates.pvxCopyNode(graph, input, output);
			LogCommand("vxCopyNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Import ImportObjectsFromMemory(Context context, UIntPtr numrefs, Reference[] refs, int[] uses, byte[] ptr, UIntPtr length)
		{
			Import retValue;

			unsafe {
				fixed (Reference* p_refs = refs)
				fixed (int* p_uses = uses)
				fixed (byte* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxImportObjectsFromMemory != null, "pvxImportObjectsFromMemory not implemented");
					retValue = Delegates.pvxImportObjectsFromMemory(context, numrefs, p_refs, p_uses, p_ptr, length);
					LogCommand("vxImportObjectsFromMemory", retValue, context, numrefs, refs, uses, ptr, length					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Release(ref Import import)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxReleaseImport != null, "pvxReleaseImport not implemented");
			retValue = Delegates.pvxReleaseImport(ref import);
			LogCommand("vxReleaseImport", retValue, import			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Reference GetImportReferenceByName(Import import, string name)
		{
			Reference retValue;

			Debug.Assert(Delegates.pvxGetImportReferenceByName != null, "pvxGetImportReferenceByName not implemented");
			retValue = Delegates.pvxGetImportReferenceByName(import, name);
			LogCommand("vxGetImportReferenceByName", retValue, import, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		internal static unsafe partial class Delegates
		{
			[SuppressUnmanagedCodeSecurity]
			internal delegate Context vxCreateContext();

			internal static vxCreateContext pvxCreateContext;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseContext(ref Context context);

			internal static vxReleaseContext pvxReleaseContext;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Context vxGetContext(Reference reference);

			internal static vxGetContext pvxGetContext;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryContext(Context context, ContextAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryContext pvxQueryContext;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetContextAttribute(Context context, ContextAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetContextAttribute pvxSetContextAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxHint(Reference reference, Hint hint, void* data, UIntPtr data_size);

			internal static vxHint pvxHint;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxDirective(Reference reference, Directive directive);

			internal static vxDirective pvxDirective;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxGetStatus(Reference reference);

			internal static vxGetStatus pvxGetStatus;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Type vxRegisterUserStruct(Context context, UIntPtr size);

			internal static vxRegisterUserStruct pvxRegisterUserStruct;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAllocateUserKernelId(Context context, Type* pKernelEnumId);

			internal static vxAllocateUserKernelId pvxAllocateUserKernelId;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAllocateUserKernelLibraryId(Context context, int* pLibraryId);

			internal static vxAllocateUserKernelLibraryId pvxAllocateUserKernelLibraryId;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetImmediateModeTarget(Context context, Target target_enum, string target_string);

			internal static vxSetImmediateModeTarget pvxSetImmediateModeTarget;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateImage(Context context, uint width, uint height, DfImage color);

			internal static vxCreateImage pvxCreateImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateImageFromROI(Image img, Rectangle* rect);

			internal static vxCreateImageFromROI pvxCreateImageFromROI;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateUniformImage(Context context, uint width, uint height, DfImage color, PixelValue value);

			internal static vxCreateUniformImage pvxCreateUniformImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateVirtualImage(Graph graph, uint width, uint height, DfImage color);

			internal static vxCreateVirtualImage pvxCreateVirtualImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateImageFromHandle(Context context, DfImage color, ImagePatchAddressing* addrs, IntPtr* ptrs, MemoryType memory_type);

			internal static vxCreateImageFromHandle pvxCreateImageFromHandle;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSwapImageHandle(Image image, IntPtr* new_ptrs, IntPtr* prev_ptrs, UIntPtr num_planes);

			internal static vxSwapImageHandle pvxSwapImageHandle;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryImage(Image image, ImageAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryImage pvxQueryImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetImageAttribute(Image image, ImageAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetImageAttribute pvxSetImageAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetImagePixelValues(Image image, PixelValue pixel_value);

			internal static vxSetImagePixelValues pvxSetImagePixelValues;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseImage(ref Image image);

			internal static vxReleaseImage pvxReleaseImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr vxFormatImagePatchAddress1d(void* ptr, uint index, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress1d pvxFormatImagePatchAddress1d;

			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr vxFormatImagePatchAddress2d(void* ptr, uint x, uint y, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress2d pvxFormatImagePatchAddress2d;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxGetValidRegionImage(Image image, Rectangle* rect);

			internal static vxGetValidRegionImage pvxGetValidRegionImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyImagePatch(Image image, ref Rectangle image_rect, uint image_plane_index, ref ImagePatchAddressing user_addr, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyImagePatch pvxCopyImagePatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxMapImagePatch(Image image, Rectangle* rect, uint plane_index, MapId* map_id, ImagePatchAddressing* addr, IntPtr* ptr, Accessor usage, MemoryType mem_type, MapFlag flags);

			internal static vxMapImagePatch pvxMapImagePatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnmapImagePatch(Image image, MapId map_id);

			internal static vxUnmapImagePatch pvxUnmapImagePatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxCreateImageFromChannel(Image img, Channel channel);

			internal static vxCreateImageFromChannel pvxCreateImageFromChannel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetImageValidRectangle(Image image, Rectangle* rect);

			internal static vxSetImageValidRectangle pvxSetImageValidRectangle;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxLoadKernels(Context context, string module);

			internal static vxLoadKernels pvxLoadKernels;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnloadKernels(Context context, string module);

			internal static vxUnloadKernels pvxUnloadKernels;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Kernel vxGetKernelByName(Context context, string name);

			internal static vxGetKernelByName pvxGetKernelByName;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Kernel vxGetKernelByEnum(Context context, KernelType kernel);

			internal static vxGetKernelByEnum pvxGetKernelByEnum;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryKernel(Kernel kernel, KernelAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryKernel pvxQueryKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseKernel(ref Kernel kernel);

			internal static vxReleaseKernel pvxReleaseKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Kernel vxAddUserKernel(Context context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit);

			internal static vxAddUserKernel pvxAddUserKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxFinalizeKernel(Kernel kernel);

			internal static vxFinalizeKernel pvxFinalizeKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAddParameterToKernel(Kernel kernel, uint index, Direction dir, Type data_type, ParameterState state);

			internal static vxAddParameterToKernel pvxAddParameterToKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxRemoveKernel(Kernel kernel);

			internal static vxRemoveKernel pvxRemoveKernel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetKernelAttribute(Kernel kernel, KernelAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetKernelAttribute pvxSetKernelAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Parameter vxGetKernelParameterByIndex(Kernel kernel, uint index);

			internal static vxGetKernelParameterByIndex pvxGetKernelParameterByIndex;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Graph vxCreateGraph(Context context);

			internal static vxCreateGraph pvxCreateGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseGraph(ref Graph graph);

			internal static vxReleaseGraph pvxReleaseGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxVerifyGraph(Graph graph);

			internal static vxVerifyGraph pvxVerifyGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxProcessGraph(Graph graph);

			internal static vxProcessGraph pvxProcessGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxScheduleGraph(Graph graph);

			internal static vxScheduleGraph pvxScheduleGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxWaitGraph(Graph graph);

			internal static vxWaitGraph pvxWaitGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryGraph(Graph graph, GraphAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryGraph pvxQueryGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetGraphAttribute(Graph graph, GraphAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetGraphAttribute pvxSetGraphAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAddParameterToGraph(Graph graph, Parameter parameter);

			internal static vxAddParameterToGraph pvxAddParameterToGraph;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetGraphParameterByIndex(Graph graph, uint index, Reference value);

			internal static vxSetGraphParameterByIndex pvxSetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Parameter vxGetGraphParameterByIndex(Graph graph, uint index);

			internal static vxGetGraphParameterByIndex pvxGetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity]
			internal delegate bool vxIsGraphVerified(Graph graph);

			internal static vxIsGraphVerified pvxIsGraphVerified;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxCreateGenericNode(Graph graph, Kernel kernel);

			internal static vxCreateGenericNode pvxCreateGenericNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryNode(Node node, NodeAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryNode pvxQueryNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetNodeAttribute(Node node, NodeAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetNodeAttribute pvxSetNodeAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseNode(ref Node node);

			internal static vxReleaseNode pvxReleaseNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxRemoveNode(Node* node);

			internal static vxRemoveNode pvxRemoveNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAssignNodeCallback(Node node, NodeCompleteCallback callback);

			internal static vxAssignNodeCallback pvxAssignNodeCallback;

			[SuppressUnmanagedCodeSecurity]
			internal delegate NodeCompleteCallback vxRetrieveNodeCallback(Node node);

			internal static vxRetrieveNodeCallback pvxRetrieveNodeCallback;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetNodeTarget(Node node, Target target_enum, string target_string);

			internal static vxSetNodeTarget pvxSetNodeTarget;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReplicateNode(Graph graph, Node first_node, bool* replicate, uint number_of_parameters);

			internal static vxReplicateNode pvxReplicateNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Parameter vxGetParameterByIndex(Node node, uint index);

			internal static vxGetParameterByIndex pvxGetParameterByIndex;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseParameter(ref Parameter param);

			internal static vxReleaseParameter pvxReleaseParameter;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetParameterByIndex(Node node, uint index, Reference value);

			internal static vxSetParameterByIndex pvxSetParameterByIndex;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetParameterByReference(Parameter parameter, Reference value);

			internal static vxSetParameterByReference pvxSetParameterByReference;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryParameter(Parameter parameter, ParameterAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryParameter pvxQueryParameter;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Scalar vxCreateScalar(Context context, Type data_type, void* ptr);

			internal static vxCreateScalar pvxCreateScalar;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Scalar vxCreateScalarWithSize(Context context, Type data_type, void* ptr, UIntPtr size);

			internal static vxCreateScalarWithSize pvxCreateScalarWithSize;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Scalar vxCreateVirtualScalar(Graph graph, Type data_type);

			internal static vxCreateVirtualScalar pvxCreateVirtualScalar;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseScalar(ref Scalar scalar);

			internal static vxReleaseScalar pvxReleaseScalar;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryScalar(Scalar scalar, ScalarAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryScalar pvxQueryScalar;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyScalar(Scalar scalar, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyScalar pvxCopyScalar;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryReference(Reference @ref, ReferenceAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryReference pvxQueryReference;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseReference(ref Reference ref_ptr);

			internal static vxReleaseReference pvxReleaseReference;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxRetainReference(Reference @ref);

			internal static vxRetainReference pvxRetainReference;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetReferenceName(Reference @ref, string name);

			internal static vxSetReferenceName pvxSetReferenceName;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryDelay(Delay delay, DelayAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryDelay pvxQueryDelay;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseDelay(ref Delay delay);

			internal static vxReleaseDelay pvxReleaseDelay;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Delay vxCreateDelay(Context context, Reference exemplar, UIntPtr num_slots);

			internal static vxCreateDelay pvxCreateDelay;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Reference vxGetReferenceFromDelay(Delay delay, int index);

			internal static vxGetReferenceFromDelay pvxGetReferenceFromDelay;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAgeDelay(Delay delay);

			internal static vxAgeDelay pvxAgeDelay;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxRegisterAutoAging(Graph graph, Delay delay);

			internal static vxRegisterAutoAging pvxRegisterAutoAging;

			[SuppressUnmanagedCodeSecurity]
			internal delegate void vxAddLogEntry(Reference @ref, Status status, string message, int vaArgs);

			internal static vxAddLogEntry pvxAddLogEntry;

			[SuppressUnmanagedCodeSecurity]
			internal delegate void vxRegisterLogCallback(Context context, LogCallback callback, bool reentrant);

			internal static vxRegisterLogCallback pvxRegisterLogCallback;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Lut vxCreateLUT(Context context, Type data_type, UIntPtr count);

			internal static vxCreateLUT pvxCreateLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Lut vxCreateVirtualLUT(Graph graph, Type data_type, UIntPtr count);

			internal static vxCreateVirtualLUT pvxCreateVirtualLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseLUT(ref Lut lut);

			internal static vxReleaseLUT pvxReleaseLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryLUT(Lut lut, LutAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryLUT pvxQueryLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyLUT(Lut lut, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyLUT pvxCopyLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxMapLUT(Lut lut, MapId* map_id, IntPtr* ptr, Accessor usage, MemoryType mem_type, uint flags);

			internal static vxMapLUT pvxMapLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnmapLUT(Lut lut, MapId map_id);

			internal static vxUnmapLUT pvxUnmapLUT;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Distribution vxCreateDistribution(Context context, UIntPtr numBins, int offset, uint range);

			internal static vxCreateDistribution pvxCreateDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Distribution vxCreateVirtualDistribution(Graph graph, UIntPtr numBins, int offset, uint range);

			internal static vxCreateVirtualDistribution pvxCreateVirtualDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseDistribution(ref Distribution distribution);

			internal static vxReleaseDistribution pvxReleaseDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryDistribution(Distribution distribution, DistributionAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryDistribution pvxQueryDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyDistribution(Distribution distribution, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyDistribution pvxCopyDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxMapDistribution(Distribution distribution, MapId* map_id, IntPtr* ptr, Accessor usage, MemoryType mem_type, uint flags);

			internal static vxMapDistribution pvxMapDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnmapDistribution(Distribution distribution, MapId map_id);

			internal static vxUnmapDistribution pvxUnmapDistribution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Threshold vxCreateThresholdForImage(Context context, int thresh_type, DfImage input_format, DfImage output_format);

			internal static vxCreateThresholdForImage pvxCreateThresholdForImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Threshold vxCreateVirtualThresholdForImage(Graph graph, int thresh_type, DfImage input_format, DfImage output_format);

			internal static vxCreateVirtualThresholdForImage pvxCreateVirtualThresholdForImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyThresholdValue(Threshold thresh, PixelValue value_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyThresholdValue pvxCopyThresholdValue;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyThresholdRange(Threshold thresh, PixelValue lower_value_ptr, PixelValue upper_value_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyThresholdRange pvxCopyThresholdRange;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyThresholdOutput(Threshold thresh, PixelValue true_value_ptr, PixelValue false_value_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyThresholdOutput pvxCopyThresholdOutput;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseThreshold(ref Threshold thresh);

			internal static vxReleaseThreshold pvxReleaseThreshold;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetThresholdAttribute(Threshold thresh, ThresholdAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetThresholdAttribute pvxSetThresholdAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryThreshold(Threshold thresh, ThresholdAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryThreshold pvxQueryThreshold;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Matrix vxCreateMatrix(Context c, Type data_type, UIntPtr columns, UIntPtr rows);

			internal static vxCreateMatrix pvxCreateMatrix;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Matrix vxCreateVirtualMatrix(Graph graph, Type data_type, UIntPtr columns, UIntPtr rows);

			internal static vxCreateVirtualMatrix pvxCreateVirtualMatrix;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseMatrix(ref Matrix mat);

			internal static vxReleaseMatrix pvxReleaseMatrix;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryMatrix(Matrix mat, MatrixAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryMatrix pvxQueryMatrix;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyMatrix(Matrix matrix, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyMatrix pvxCopyMatrix;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Matrix vxCreateMatrixFromPattern(Context context, MatrixAttribute pattern, UIntPtr columns, UIntPtr rows);

			internal static vxCreateMatrixFromPattern pvxCreateMatrixFromPattern;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Matrix vxCreateMatrixFromPatternAndOrigin(Context context, Pattern pattern, UIntPtr columns, UIntPtr rows, UIntPtr origin_col, UIntPtr origin_row);

			internal static vxCreateMatrixFromPatternAndOrigin pvxCreateMatrixFromPatternAndOrigin;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Convolution vxCreateConvolution(Context context, UIntPtr columns, UIntPtr rows);

			internal static vxCreateConvolution pvxCreateConvolution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Convolution vxCreateVirtualConvolution(Graph graph, UIntPtr columns, UIntPtr rows);

			internal static vxCreateVirtualConvolution pvxCreateVirtualConvolution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseConvolution(ref Convolution conv);

			internal static vxReleaseConvolution pvxReleaseConvolution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryConvolution(Convolution conv, ConvolutionAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryConvolution pvxQueryConvolution;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetConvolutionAttribute(Convolution conv, ConvolutionAttribute attribute, void* ptr, UIntPtr size);

			internal static vxSetConvolutionAttribute pvxSetConvolutionAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyConvolutionCoefficients(Convolution conv, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyConvolutionCoefficients pvxCopyConvolutionCoefficients;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Pyramid vxCreatePyramid(Context context, UIntPtr levels, float scale, uint width, uint height, DfImage format);

			internal static vxCreatePyramid pvxCreatePyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Pyramid vxCreateVirtualPyramid(Graph graph, UIntPtr levels, float scale, uint width, uint height, DfImage format);

			internal static vxCreateVirtualPyramid pvxCreateVirtualPyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleasePyramid(ref Pyramid pyr);

			internal static vxReleasePyramid pvxReleasePyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryPyramid(Pyramid pyr, PyramidAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryPyramid pvxQueryPyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Image vxGetPyramidLevel(Pyramid pyr, uint index);

			internal static vxGetPyramidLevel pvxGetPyramidLevel;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Remap vxCreateRemap(Context context, uint src_width, uint src_height, uint dst_width, uint dst_height);

			internal static vxCreateRemap pvxCreateRemap;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Remap vxCreateVirtualRemap(Graph graph, uint src_width, uint src_height, uint dst_width, uint dst_height);

			internal static vxCreateVirtualRemap pvxCreateVirtualRemap;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseRemap(ref Remap table);

			internal static vxReleaseRemap pvxReleaseRemap;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxMapRemapPatch(Remap remap, Rectangle* rect, MapId* map_id, UIntPtr* stride_y, IntPtr* ptr, Type coordinate_type, Accessor usage, MemoryType mem_type);

			internal static vxMapRemapPatch pvxMapRemapPatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnmapRemapPatch(Remap remap, MapId map_id);

			internal static vxUnmapRemapPatch pvxUnmapRemapPatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyRemapPatch(Remap remap, Rectangle* rect, UIntPtr user_stride_y, void* user_ptr, Type user_coordinate_type, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyRemapPatch pvxCopyRemapPatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryRemap(Remap table, RemapAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryRemap pvxQueryRemap;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Array vxCreateArray(Context context, Type item_type, UIntPtr capacity);

			internal static vxCreateArray pvxCreateArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Array vxCreateVirtualArray(Graph graph, Type item_type, UIntPtr capacity);

			internal static vxCreateVirtualArray pvxCreateVirtualArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseArray(ref Array arr);

			internal static vxReleaseArray pvxReleaseArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryArray(Array arr, ArrayAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryArray pvxQueryArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxAddArrayItems(Array arr, UIntPtr count, void* ptr, UIntPtr stride);

			internal static vxAddArrayItems pvxAddArrayItems;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxTruncateArray(Array arr, UIntPtr new_num_items);

			internal static vxTruncateArray pvxTruncateArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyArrayRange(Array array, UIntPtr range_start, UIntPtr range_end, UIntPtr user_stride, void* user_ptr, Accessor usage, MemoryType user_mem_type);

			internal static vxCopyArrayRange pvxCopyArrayRange;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxMapArrayRange(Array array, UIntPtr range_start, UIntPtr range_end, ref MapId map_id, ref UIntPtr stride, out IntPtr ptr, Accessor usage, MemoryType mem_type, uint flags);

			internal static vxMapArrayRange pvxMapArrayRange;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxUnmapArrayRange(Array array, MapId map_id);

			internal static vxUnmapArrayRange pvxUnmapArrayRange;

			[SuppressUnmanagedCodeSecurity]
			internal delegate ObjectArray vxCreateObjectArray(Context context, Reference exemplar, UIntPtr count);

			internal static vxCreateObjectArray pvxCreateObjectArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate ObjectArray vxCreateVirtualObjectArray(Graph graph, Reference exemplar, UIntPtr count);

			internal static vxCreateVirtualObjectArray pvxCreateVirtualObjectArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Reference vxGetObjectArrayItem(ObjectArray arr, uint index);

			internal static vxGetObjectArrayItem pvxGetObjectArrayItem;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseObjectArray(ref ObjectArray arr);

			internal static vxReleaseObjectArray pvxReleaseObjectArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryObjectArray(ObjectArray arr, ObjectArrayAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryObjectArray pvxQueryObjectArray;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetMetaFormatAttribute(MetaFormat meta, int attribute, void* ptr, UIntPtr size);

			internal static vxSetMetaFormatAttribute pvxSetMetaFormatAttribute;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxSetMetaFormatFromReference(MetaFormat meta, Reference exemplar);

			internal static vxSetMetaFormatFromReference pvxSetMetaFormatFromReference;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Tensor vxCreateTensor(Context context, UIntPtr number_of_dims, UIntPtr* dims, Type data_type, sbyte fixed_point_position);

			internal static vxCreateTensor pvxCreateTensor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate ObjectArray vxCreateImageObjectArrayFromTensor(Tensor tensor, Rectangle* rect, UIntPtr array_size, UIntPtr jump, DfImage image_format);

			internal static vxCreateImageObjectArrayFromTensor pvxCreateImageObjectArrayFromTensor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Tensor vxCreateTensorFromView(Tensor tensor, UIntPtr number_of_dims, UIntPtr* view_start, UIntPtr* view_end);

			internal static vxCreateTensorFromView pvxCreateTensorFromView;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Tensor vxCreateVirtualTensor(Graph graph, UIntPtr number_of_dims, UIntPtr* dims, Type data_type, sbyte fixed_point_position);

			internal static vxCreateVirtualTensor pvxCreateVirtualTensor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxCopyTensorPatch(Tensor tensor, UIntPtr number_of_dims, UIntPtr* view_start, UIntPtr* view_end, UIntPtr* user_stride, void* user_ptr, Accessor usage, MemoryType user_memory_type);

			internal static vxCopyTensorPatch pvxCopyTensorPatch;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxQueryTensor(Tensor tensor, TensorAttribute attribute, void* ptr, UIntPtr size);

			internal static vxQueryTensor pvxQueryTensor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseTensor(ref Tensor tensor);

			internal static vxReleaseTensor pvxReleaseTensor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxColorConvertNode(Graph graph, Image input, Image output);

			internal static vxColorConvertNode pvxColorConvertNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxChannelExtractNode(Graph graph, Image input, Channel channel, Image output);

			internal static vxChannelExtractNode pvxChannelExtractNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxChannelCombineNode(Graph graph, Image plane0, Image plane1, Image plane2, Image plane3, Image output);

			internal static vxChannelCombineNode pvxChannelCombineNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxPhaseNode(Graph graph, Image grad_x, Image grad_y, Image orientation);

			internal static vxPhaseNode pvxPhaseNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxSobel3x3Node(Graph graph, Image input, Image output_x, Image output_y);

			internal static vxSobel3x3Node pvxSobel3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMagnitudeNode(Graph graph, Image grad_x, Image grad_y, Image mag);

			internal static vxMagnitudeNode pvxMagnitudeNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxScaleImageNode(Graph graph, Image src, Image dst, InterpolationType type);

			internal static vxScaleImageNode pvxScaleImageNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTableLookupNode(Graph graph, Image input, Lut lut, Image output);

			internal static vxTableLookupNode pvxTableLookupNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHistogramNode(Graph graph, Image input, Distribution distribution);

			internal static vxHistogramNode pvxHistogramNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxEqualizeHistNode(Graph graph, Image input, Image output);

			internal static vxEqualizeHistNode pvxEqualizeHistNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAbsDiffNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxAbsDiffNode pvxAbsDiffNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMeanStdDevNode(Graph graph, Image input, Scalar mean, Scalar stddev);

			internal static vxMeanStdDevNode pvxMeanStdDevNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxThresholdNode(Graph graph, Image input, Threshold thresh, Image output);

			internal static vxThresholdNode pvxThresholdNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxNonMaxSuppressionNode(Graph graph, Image input, Image mask, int win_size, Image output);

			internal static vxNonMaxSuppressionNode pvxNonMaxSuppressionNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxIntegralImageNode(Graph graph, Image input, Image output);

			internal static vxIntegralImageNode pvxIntegralImageNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxErode3x3Node(Graph graph, Image input, Image output);

			internal static vxErode3x3Node pvxErode3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxDilate3x3Node(Graph graph, Image input, Image output);

			internal static vxDilate3x3Node pvxDilate3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMedian3x3Node(Graph graph, Image input, Image output);

			internal static vxMedian3x3Node pvxMedian3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxBox3x3Node(Graph graph, Image input, Image output);

			internal static vxBox3x3Node pvxBox3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxGaussian3x3Node(Graph graph, Image input, Image output);

			internal static vxGaussian3x3Node pvxGaussian3x3Node;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxNonLinearFilterNode(Graph graph, NonLinearFilter function, Image input, Matrix mask, Image output);

			internal static vxNonLinearFilterNode pvxNonLinearFilterNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxConvolveNode(Graph graph, Image input, Convolution conv, Image output);

			internal static vxConvolveNode pvxConvolveNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxGaussianPyramidNode(Graph graph, Image input, Pyramid gaussian);

			internal static vxGaussianPyramidNode pvxGaussianPyramidNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxLaplacianPyramidNode(Graph graph, Image input, Pyramid laplacian, Image output);

			internal static vxLaplacianPyramidNode pvxLaplacianPyramidNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxLaplacianReconstructNode(Graph graph, Pyramid laplacian, Image input, Image output);

			internal static vxLaplacianReconstructNode pvxLaplacianReconstructNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAccumulateImageNode(Graph graph, Image input, Image accum);

			internal static vxAccumulateImageNode pvxAccumulateImageNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAccumulateWeightedImageNode(Graph graph, Image input, Scalar alpha, Image accum);

			internal static vxAccumulateWeightedImageNode pvxAccumulateWeightedImageNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAccumulateSquareImageNode(Graph graph, Image input, Scalar shift, Image accum);

			internal static vxAccumulateSquareImageNode pvxAccumulateSquareImageNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMinMaxLocNode(Graph graph, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount);

			internal static vxMinMaxLocNode pvxMinMaxLocNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMinNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxMinNode pvxMinNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMaxNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxMaxNode pvxMaxNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAndNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxAndNode pvxAndNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxOrNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxOrNode pvxOrNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxXorNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxXorNode pvxXorNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxNotNode(Graph graph, Image input, Image output);

			internal static vxNotNode pvxNotNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxScalarOperationNode(Graph graph, ScalarOperation scalar_operation, Scalar a, Scalar b, Scalar output);

			internal static vxScalarOperationNode pvxScalarOperationNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxSelectNode(Graph graph, Scalar condition, Reference true_value, Reference false_value, Reference output);

			internal static vxSelectNode pvxSelectNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMultiplyNode(Graph graph, Image in1, Image in2, Scalar scale, ConvertPolicy overflow_policy, RoundPolicy rounding_policy, Image @out);

			internal static vxMultiplyNode pvxMultiplyNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxAddNode(Graph graph, Image in1, Image in2, ConvertPolicy policy, Image @out);

			internal static vxAddNode pvxAddNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxSubtractNode(Graph graph, Image in1, Image in2, ConvertPolicy policy, Image @out);

			internal static vxSubtractNode pvxSubtractNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxConvertDepthNode(Graph graph, Image input, Image output, ConvertPolicy policy, Scalar shift);

			internal static vxConvertDepthNode pvxConvertDepthNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxCannyEdgeDetectorNode(Graph graph, Image input, Threshold hyst, int gradient_size, NormType norm_type, Image output);

			internal static vxCannyEdgeDetectorNode pvxCannyEdgeDetectorNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxWarpAffineNode(Graph graph, Image input, Matrix matrix, InterpolationType type, Image output);

			internal static vxWarpAffineNode pvxWarpAffineNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxWarpPerspectiveNode(Graph graph, Image input, Matrix matrix, InterpolationType type, Image output);

			internal static vxWarpPerspectiveNode pvxWarpPerspectiveNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHarrisCornersNode(Graph graph, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners);

			internal static vxHarrisCornersNode pvxHarrisCornersNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxFastCornersNode(Graph graph, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners);

			internal static vxFastCornersNode pvxFastCornersNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxOpticalFlowPyrLKNode(Graph graph, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, TerminationCriteria termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, UIntPtr window_dimension);

			internal static vxOpticalFlowPyrLKNode pvxOpticalFlowPyrLKNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxRemapNode(Graph graph, Image input, Remap table, InterpolationType policy, Image output);

			internal static vxRemapNode pvxRemapNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHalfScaleGaussianNode(Graph graph, Image input, Image output, int kernel_size);

			internal static vxHalfScaleGaussianNode pvxHalfScaleGaussianNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMatchTemplateNode(Graph graph, Image src, Image templateImage, CompareMetric matchingMethod, Image output);

			internal static vxMatchTemplateNode pvxMatchTemplateNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxLBPNode(Graph graph, Image @in, LbpFormat format, sbyte kernel_size, Image @out);

			internal static vxLBPNode pvxLBPNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHOGFeaturesNode(Graph graph, Image input, Tensor magnitudes, Tensor bins, Hog* @params, UIntPtr hog_param_size, Tensor features);

			internal static vxHOGFeaturesNode pvxHOGFeaturesNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHOGCellsNode(Graph graph, Image input, int cell_width, int cell_height, int num_bins, Tensor magnitudes, Tensor bins);

			internal static vxHOGCellsNode pvxHOGCellsNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxHoughLinesPNode(Graph graph, Image input, HoughLinesParams* @params, Array lines_array, Scalar num_lines);

			internal static vxHoughLinesPNode pvxHoughLinesPNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxBilateralFilterNode(Graph graph, Tensor src, int diameter, float sigmaSpace, float sigmaValues, Tensor dst);

			internal static vxBilateralFilterNode pvxBilateralFilterNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorMultiplyNode(Graph graph, Tensor input1, Tensor input2, Scalar scale, ConvertPolicy overflow_policy, RoundPolicy rounding_policy, Tensor output);

			internal static vxTensorMultiplyNode pvxTensorMultiplyNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorAddNode(Graph graph, Tensor input1, Tensor input2, ConvertPolicy policy, Tensor output);

			internal static vxTensorAddNode pvxTensorAddNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorSubtractNode(Graph graph, Tensor input1, Tensor input2, ConvertPolicy policy, Tensor output);

			internal static vxTensorSubtractNode pvxTensorSubtractNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorTableLookupNode(Graph graph, Tensor input1, Lut lut, Tensor output);

			internal static vxTensorTableLookupNode pvxTensorTableLookupNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorTransposeNode(Graph graph, Tensor input, Tensor output, UIntPtr dimension1, UIntPtr dimension2);

			internal static vxTensorTransposeNode pvxTensorTransposeNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxTensorConvertDepthNode(Graph graph, Tensor input, ConvertPolicy policy, Scalar norm, Scalar offset, Tensor output);

			internal static vxTensorConvertDepthNode pvxTensorConvertDepthNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxMatrixMultiplyNode(Graph graph, Tensor input1, Tensor input2, Tensor input3, MatrixMulParams* matrix_multiply_params, Tensor output);

			internal static vxMatrixMultiplyNode pvxMatrixMultiplyNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Node vxCopyNode(Graph graph, Reference input, Reference output);

			internal static vxCopyNode pvxCopyNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Import vxImportObjectsFromMemory(Context context, UIntPtr numrefs, Reference* refs, int* uses, byte* ptr, UIntPtr length);

			internal static vxImportObjectsFromMemory pvxImportObjectsFromMemory;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxReleaseImport(ref Import import);

			internal static vxReleaseImport pvxReleaseImport;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Reference vxGetImportReferenceByName(Import import, string name);

			internal static vxGetImportReferenceByName pvxGetImportReferenceByName;

		}
	}

}

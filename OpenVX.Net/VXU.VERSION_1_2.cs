
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

// ReSharper disable RedundantUsingDirective
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable JoinDeclarationAndInitializer

namespace OpenVX
{
	public partial class VXU
	{
		public static Status ColorConvert(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuColorConvert != null, "pvxuColorConvert not implemented");
			retValue = Delegates.pvxuColorConvert(context, input, output);
			LogCommand("vxuColorConvert", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ChannelExtract(Context context, Image input, int channel, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuChannelExtract != null, "pvxuChannelExtract not implemented");
			retValue = Delegates.pvxuChannelExtract(context, input, channel, output);
			LogCommand("vxuChannelExtract", retValue, context, input, channel, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ChannelCombine(Context context, Image plane0, Image plane1, Image plane2, Image plane3, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuChannelCombine != null, "pvxuChannelCombine not implemented");
			retValue = Delegates.pvxuChannelCombine(context, plane0, plane1, plane2, plane3, output);
			LogCommand("vxuChannelCombine", retValue, context, plane0, plane1, plane2, plane3, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Sobel3x3(Context context, Image input, Image output_x, Image output_y)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuSobel3x3 != null, "pvxuSobel3x3 not implemented");
			retValue = Delegates.pvxuSobel3x3(context, input, output_x, output_y);
			LogCommand("vxuSobel3x3", retValue, context, input, output_x, output_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Magnitude(Context context, Image grad_x, Image grad_y, Image mag)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMagnitude != null, "pvxuMagnitude not implemented");
			retValue = Delegates.pvxuMagnitude(context, grad_x, grad_y, mag);
			LogCommand("vxuMagnitude", retValue, context, grad_x, grad_y, mag			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Phase(Context context, Image grad_x, Image grad_y, Image orientation)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuPhase != null, "pvxuPhase not implemented");
			retValue = Delegates.pvxuPhase(context, grad_x, grad_y, orientation);
			LogCommand("vxuPhase", retValue, context, grad_x, grad_y, orientation			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ScaleImage(Context context, Image src, Image dst, int type)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuScaleImage != null, "pvxuScaleImage not implemented");
			retValue = Delegates.pvxuScaleImage(context, src, dst, type);
			LogCommand("vxuScaleImage", retValue, context, src, dst, type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TableLookup(Context context, Image input, Lut lut, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTableLookup != null, "pvxuTableLookup not implemented");
			retValue = Delegates.pvxuTableLookup(context, input, lut, output);
			LogCommand("vxuTableLookup", retValue, context, input, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Histogram(Context context, Image input, Distribution distribution)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuHistogram != null, "pvxuHistogram not implemented");
			retValue = Delegates.pvxuHistogram(context, input, distribution);
			LogCommand("vxuHistogram", retValue, context, input, distribution			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status EqualizeHist(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuEqualizeHist != null, "pvxuEqualizeHist not implemented");
			retValue = Delegates.pvxuEqualizeHist(context, input, output);
			LogCommand("vxuEqualizeHist", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AbsDiff(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAbsDiff != null, "pvxuAbsDiff not implemented");
			retValue = Delegates.pvxuAbsDiff(context, in1, in2, @out);
			LogCommand("vxuAbsDiff", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MeanStdDev(Context context, Image input, float[] mean, float[] stddev)
		{
			Status retValue;

			unsafe {
				fixed (float* p_mean = mean)
				fixed (float* p_stddev = stddev)
				{
					Debug.Assert(Delegates.pvxuMeanStdDev != null, "pvxuMeanStdDev not implemented");
					retValue = Delegates.pvxuMeanStdDev(context, input, p_mean, p_stddev);
					LogCommand("vxuMeanStdDev", retValue, context, input, mean, stddev					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Threshold(Context context, Image input, Threshold thresh, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuThreshold != null, "pvxuThreshold not implemented");
			retValue = Delegates.pvxuThreshold(context, input, thresh, output);
			LogCommand("vxuThreshold", retValue, context, input, thresh, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status NonMaxSuppression(Context context, Image input, Image mask, int win_size, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuNonMaxSuppression != null, "pvxuNonMaxSuppression not implemented");
			retValue = Delegates.pvxuNonMaxSuppression(context, input, mask, win_size, output);
			LogCommand("vxuNonMaxSuppression", retValue, context, input, mask, win_size, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status IntegralImage(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuIntegralImage != null, "pvxuIntegralImage not implemented");
			retValue = Delegates.pvxuIntegralImage(context, input, output);
			LogCommand("vxuIntegralImage", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Erode3x3(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuErode3x3 != null, "pvxuErode3x3 not implemented");
			retValue = Delegates.pvxuErode3x3(context, input, output);
			LogCommand("vxuErode3x3", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Dilate3x3(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuDilate3x3 != null, "pvxuDilate3x3 not implemented");
			retValue = Delegates.pvxuDilate3x3(context, input, output);
			LogCommand("vxuDilate3x3", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Median3x3(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMedian3x3 != null, "pvxuMedian3x3 not implemented");
			retValue = Delegates.pvxuMedian3x3(context, input, output);
			LogCommand("vxuMedian3x3", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Box3x3(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuBox3x3 != null, "pvxuBox3x3 not implemented");
			retValue = Delegates.pvxuBox3x3(context, input, output);
			LogCommand("vxuBox3x3", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Gaussian3x3(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuGaussian3x3 != null, "pvxuGaussian3x3 not implemented");
			retValue = Delegates.pvxuGaussian3x3(context, input, output);
			LogCommand("vxuGaussian3x3", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status NonLinearFilter(Context context, int function, Image input, Matrix mask, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuNonLinearFilter != null, "pvxuNonLinearFilter not implemented");
			retValue = Delegates.pvxuNonLinearFilter(context, function, input, mask, output);
			LogCommand("vxuNonLinearFilter", retValue, context, function, input, mask, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Convolve(Context context, Image input, Convolution conv, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuConvolve != null, "pvxuConvolve not implemented");
			retValue = Delegates.pvxuConvolve(context, input, conv, output);
			LogCommand("vxuConvolve", retValue, context, input, conv, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GaussianPyramid(Context context, Image input, Pyramid gaussian)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuGaussianPyramid != null, "pvxuGaussianPyramid not implemented");
			retValue = Delegates.pvxuGaussianPyramid(context, input, gaussian);
			LogCommand("vxuGaussianPyramid", retValue, context, input, gaussian			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status LaplacianPyramid(Context context, Image input, Pyramid laplacian, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuLaplacianPyramid != null, "pvxuLaplacianPyramid not implemented");
			retValue = Delegates.pvxuLaplacianPyramid(context, input, laplacian, output);
			LogCommand("vxuLaplacianPyramid", retValue, context, input, laplacian, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status LaplacianReconstruct(Context context, Pyramid laplacian, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuLaplacianReconstruct != null, "pvxuLaplacianReconstruct not implemented");
			retValue = Delegates.pvxuLaplacianReconstruct(context, laplacian, input, output);
			LogCommand("vxuLaplacianReconstruct", retValue, context, laplacian, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AccumulateImage(Context context, Image input, Image accum)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAccumulateImage != null, "pvxuAccumulateImage not implemented");
			retValue = Delegates.pvxuAccumulateImage(context, input, accum);
			LogCommand("vxuAccumulateImage", retValue, context, input, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AccumulateWeightedImage(Context context, Image input, Scalar alpha, Image accum)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAccumulateWeightedImage != null, "pvxuAccumulateWeightedImage not implemented");
			retValue = Delegates.pvxuAccumulateWeightedImage(context, input, alpha, accum);
			LogCommand("vxuAccumulateWeightedImage", retValue, context, input, alpha, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AccumulateSquareImage(Context context, Image input, Scalar shift, Image accum)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAccumulateSquareImage != null, "pvxuAccumulateSquareImage not implemented");
			retValue = Delegates.pvxuAccumulateSquareImage(context, input, shift, accum);
			LogCommand("vxuAccumulateSquareImage", retValue, context, input, shift, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MinMaxLoc(Context context, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMinMaxLoc != null, "pvxuMinMaxLoc not implemented");
			retValue = Delegates.pvxuMinMaxLoc(context, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount);
			LogCommand("vxuMinMaxLoc", retValue, context, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Min(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMin != null, "pvxuMin not implemented");
			retValue = Delegates.pvxuMin(context, in1, in2, @out);
			LogCommand("vxuMin", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Max(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMax != null, "pvxuMax not implemented");
			retValue = Delegates.pvxuMax(context, in1, in2, @out);
			LogCommand("vxuMax", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ConvertDepth(Context context, Image input, Image output, int policy, int shift)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuConvertDepth != null, "pvxuConvertDepth not implemented");
			retValue = Delegates.pvxuConvertDepth(context, input, output, policy, shift);
			LogCommand("vxuConvertDepth", retValue, context, input, output, policy, shift			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CannyEdgeDetector(Context context, Image input, Threshold hyst, int gradient_size, int norm_type, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuCannyEdgeDetector != null, "pvxuCannyEdgeDetector not implemented");
			retValue = Delegates.pvxuCannyEdgeDetector(context, input, hyst, gradient_size, norm_type, output);
			LogCommand("vxuCannyEdgeDetector", retValue, context, input, hyst, gradient_size, norm_type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status HalfScaleGaussian(Context context, Image input, Image output, int kernel_size)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuHalfScaleGaussian != null, "pvxuHalfScaleGaussian not implemented");
			retValue = Delegates.pvxuHalfScaleGaussian(context, input, output, kernel_size);
			LogCommand("vxuHalfScaleGaussian", retValue, context, input, output, kernel_size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status And(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAnd != null, "pvxuAnd not implemented");
			retValue = Delegates.pvxuAnd(context, in1, in2, @out);
			LogCommand("vxuAnd", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Or(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuOr != null, "pvxuOr not implemented");
			retValue = Delegates.pvxuOr(context, in1, in2, @out);
			LogCommand("vxuOr", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Xor(Context context, Image in1, Image in2, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuXor != null, "pvxuXor not implemented");
			retValue = Delegates.pvxuXor(context, in1, in2, @out);
			LogCommand("vxuXor", retValue, context, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Not(Context context, Image input, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuNot != null, "pvxuNot not implemented");
			retValue = Delegates.pvxuNot(context, input, output);
			LogCommand("vxuNot", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Multiply(Context context, Image in1, Image in2, float scale, int overflow_policy, int rounding_policy, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMultiply != null, "pvxuMultiply not implemented");
			retValue = Delegates.pvxuMultiply(context, in1, in2, scale, overflow_policy, rounding_policy, @out);
			LogCommand("vxuMultiply", retValue, context, in1, in2, scale, overflow_policy, rounding_policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Add(Context context, Image in1, Image in2, int policy, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuAdd != null, "pvxuAdd not implemented");
			retValue = Delegates.pvxuAdd(context, in1, in2, policy, @out);
			LogCommand("vxuAdd", retValue, context, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Subtract(Context context, Image in1, Image in2, int policy, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuSubtract != null, "pvxuSubtract not implemented");
			retValue = Delegates.pvxuSubtract(context, in1, in2, policy, @out);
			LogCommand("vxuSubtract", retValue, context, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status WarpAffine(Context context, Image input, Matrix matrix, int type, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuWarpAffine != null, "pvxuWarpAffine not implemented");
			retValue = Delegates.pvxuWarpAffine(context, input, matrix, type, output);
			LogCommand("vxuWarpAffine", retValue, context, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status WarpPerspective(Context context, Image input, Matrix matrix, int type, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuWarpPerspective != null, "pvxuWarpPerspective not implemented");
			retValue = Delegates.pvxuWarpPerspective(context, input, matrix, type, output);
			LogCommand("vxuWarpPerspective", retValue, context, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status HarrisCorners(Context context, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuHarrisCorners != null, "pvxuHarrisCorners not implemented");
			retValue = Delegates.pvxuHarrisCorners(context, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners);
			LogCommand("vxuHarrisCorners", retValue, context, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status FastCorners(Context context, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuFastCorners != null, "pvxuFastCorners not implemented");
			retValue = Delegates.pvxuFastCorners(context, input, strength_thresh, nonmax_suppression, corners, num_corners);
			LogCommand("vxuFastCorners", retValue, context, input, strength_thresh, nonmax_suppression, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status OpticalFlowPyrLK(Context context, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, int termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, UIntPtr window_dimension)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuOpticalFlowPyrLK != null, "pvxuOpticalFlowPyrLK not implemented");
			retValue = Delegates.pvxuOpticalFlowPyrLK(context, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension);
			LogCommand("vxuOpticalFlowPyrLK", retValue, context, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MatchTemplateNode(Context context, Image src, Image templateImage, int matchingMethod, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuMatchTemplateNode != null, "pvxuMatchTemplateNode not implemented");
			retValue = Delegates.pvxuMatchTemplateNode(context, src, templateImage, matchingMethod, output);
			LogCommand("vxuMatchTemplateNode", retValue, context, src, templateImage, matchingMethod, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status LBPNode(Context context, Image @in, int format, sbyte kernel_size, Image @out)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuLBPNode != null, "pvxuLBPNode not implemented");
			retValue = Delegates.pvxuLBPNode(context, @in, format, kernel_size, @out);
			LogCommand("vxuLBPNode", retValue, context, @in, format, kernel_size, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status HOGFeatures(Context context, Image input, Tensor magnitudes, Tensor bins, Hog[] @params, UIntPtr hog_param_size, Tensor features)
		{
			Status retValue;

			unsafe {
				fixed (Hog* p_params = @params)
				{
					Debug.Assert(Delegates.pvxuHOGFeatures != null, "pvxuHOGFeatures not implemented");
					retValue = Delegates.pvxuHOGFeatures(context, input, magnitudes, bins, p_params, hog_param_size, features);
					LogCommand("vxuHOGFeatures", retValue, context, input, magnitudes, bins, @params, hog_param_size, features					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status HOGCells(Context context, Image input, int cell_size, int num_bins, Tensor magnitudes, Tensor bins)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuHOGCells != null, "pvxuHOGCells not implemented");
			retValue = Delegates.pvxuHOGCells(context, input, cell_size, num_bins, magnitudes, bins);
			LogCommand("vxuHOGCells", retValue, context, input, cell_size, num_bins, magnitudes, bins			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status HoughLinesPNode(Context context, Image input, HoughLinesParams[] @params, Array lines_array, Scalar num_lines)
		{
			Status retValue;

			unsafe {
				fixed (HoughLinesParams* p_params = @params)
				{
					Debug.Assert(Delegates.pvxuHoughLinesPNode != null, "pvxuHoughLinesPNode not implemented");
					retValue = Delegates.pvxuHoughLinesPNode(context, input, p_params, lines_array, num_lines);
					LogCommand("vxuHoughLinesPNode", retValue, context, input, @params, lines_array, num_lines					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Remap(Context context, Image input, Remap table, int policy, Image output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuRemap != null, "pvxuRemap not implemented");
			retValue = Delegates.pvxuRemap(context, input, table, policy, output);
			LogCommand("vxuRemap", retValue, context, input, table, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status BilateralFilter(Context context, Tensor src, int diameter, float sigmaSpace, float sigmaValues, Tensor dst)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuBilateralFilter != null, "pvxuBilateralFilter not implemented");
			retValue = Delegates.pvxuBilateralFilter(context, src, diameter, sigmaSpace, sigmaValues, dst);
			LogCommand("vxuBilateralFilter", retValue, context, src, diameter, sigmaSpace, sigmaValues, dst			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TensorMultiply(Context context, Tensor input1, Tensor input2, Scalar scale, int overflow_policy, int rounding_policy, Tensor output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorMultiply != null, "pvxuTensorMultiply not implemented");
			retValue = Delegates.pvxuTensorMultiply(context, input1, input2, scale, overflow_policy, rounding_policy, output);
			LogCommand("vxuTensorMultiply", retValue, context, input1, input2, scale, overflow_policy, rounding_policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TensorAdd(Context context, Tensor input1, Tensor input2, int policy, Tensor output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorAdd != null, "pvxuTensorAdd not implemented");
			retValue = Delegates.pvxuTensorAdd(context, input1, input2, policy, output);
			LogCommand("vxuTensorAdd", retValue, context, input1, input2, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TensorSubtract(Context context, Tensor input1, Tensor input2, int policy, Tensor output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorSubtract != null, "pvxuTensorSubtract not implemented");
			retValue = Delegates.pvxuTensorSubtract(context, input1, input2, policy, output);
			LogCommand("vxuTensorSubtract", retValue, context, input1, input2, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TensorTableLookup(Context context, Tensor input1, Lut lut, Tensor output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorTableLookup != null, "pvxuTensorTableLookup not implemented");
			retValue = Delegates.pvxuTensorTableLookup(context, input1, lut, output);
			LogCommand("vxuTensorTableLookup", retValue, context, input1, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Tensor(Context context, Tensor input, Tensor output, UIntPtr dimension1, UIntPtr dimension2)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorTranspose != null, "pvxuTensorTranspose not implemented");
			retValue = Delegates.pvxuTensorTranspose(context, input, output, dimension1, dimension2);
			LogCommand("vxuTensorTranspose", retValue, context, input, output, dimension1, dimension2			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TensorConvertDepth(Context context, Tensor input, int policy, Scalar norm, Scalar offset, Tensor output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuTensorConvertDepth != null, "pvxuTensorConvertDepth not implemented");
			retValue = Delegates.pvxuTensorConvertDepth(context, input, policy, norm, offset, output);
			LogCommand("vxuTensorConvertDepth", retValue, context, input, policy, norm, offset, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MatrixMultiply(Context context, Tensor input1, Tensor input2, Tensor input3, MatrixMulParams[] matrix_multiply_params, Tensor output)
		{
			Status retValue;

			unsafe {
				fixed (MatrixMulParams* p_matrix_multiply_params = matrix_multiply_params)
				{
					Debug.Assert(Delegates.pvxuMatrixMultiply != null, "pvxuMatrixMultiply not implemented");
					retValue = Delegates.pvxuMatrixMultiply(context, input1, input2, input3, p_matrix_multiply_params, output);
					LogCommand("vxuMatrixMultiply", retValue, context, input1, input2, input3, matrix_multiply_params, output					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Copy(Context context, Reference input, Reference output)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxuCopy != null, "pvxuCopy not implemented");
			retValue = Delegates.pvxuCopy(context, input, output);
			LogCommand("vxuCopy", retValue, context, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		internal static unsafe partial class Delegates
		{
			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuColorConvert(Context context, Image input, Image output);

			internal static vxuColorConvert pvxuColorConvert;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuChannelExtract(Context context, Image input, int channel, Image output);

			internal static vxuChannelExtract pvxuChannelExtract;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuChannelCombine(Context context, Image plane0, Image plane1, Image plane2, Image plane3, Image output);

			internal static vxuChannelCombine pvxuChannelCombine;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuSobel3x3(Context context, Image input, Image output_x, Image output_y);

			internal static vxuSobel3x3 pvxuSobel3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMagnitude(Context context, Image grad_x, Image grad_y, Image mag);

			internal static vxuMagnitude pvxuMagnitude;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuPhase(Context context, Image grad_x, Image grad_y, Image orientation);

			internal static vxuPhase pvxuPhase;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuScaleImage(Context context, Image src, Image dst, int type);

			internal static vxuScaleImage pvxuScaleImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTableLookup(Context context, Image input, Lut lut, Image output);

			internal static vxuTableLookup pvxuTableLookup;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHistogram(Context context, Image input, Distribution distribution);

			internal static vxuHistogram pvxuHistogram;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuEqualizeHist(Context context, Image input, Image output);

			internal static vxuEqualizeHist pvxuEqualizeHist;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAbsDiff(Context context, Image in1, Image in2, Image @out);

			internal static vxuAbsDiff pvxuAbsDiff;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMeanStdDev(Context context, Image input, float* mean, float* stddev);

			internal static vxuMeanStdDev pvxuMeanStdDev;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuThreshold(Context context, Image input, Threshold thresh, Image output);

			internal static vxuThreshold pvxuThreshold;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuNonMaxSuppression(Context context, Image input, Image mask, int win_size, Image output);

			internal static vxuNonMaxSuppression pvxuNonMaxSuppression;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuIntegralImage(Context context, Image input, Image output);

			internal static vxuIntegralImage pvxuIntegralImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuErode3x3(Context context, Image input, Image output);

			internal static vxuErode3x3 pvxuErode3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuDilate3x3(Context context, Image input, Image output);

			internal static vxuDilate3x3 pvxuDilate3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMedian3x3(Context context, Image input, Image output);

			internal static vxuMedian3x3 pvxuMedian3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuBox3x3(Context context, Image input, Image output);

			internal static vxuBox3x3 pvxuBox3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuGaussian3x3(Context context, Image input, Image output);

			internal static vxuGaussian3x3 pvxuGaussian3x3;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuNonLinearFilter(Context context, int function, Image input, Matrix mask, Image output);

			internal static vxuNonLinearFilter pvxuNonLinearFilter;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuConvolve(Context context, Image input, Convolution conv, Image output);

			internal static vxuConvolve pvxuConvolve;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuGaussianPyramid(Context context, Image input, Pyramid gaussian);

			internal static vxuGaussianPyramid pvxuGaussianPyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuLaplacianPyramid(Context context, Image input, Pyramid laplacian, Image output);

			internal static vxuLaplacianPyramid pvxuLaplacianPyramid;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuLaplacianReconstruct(Context context, Pyramid laplacian, Image input, Image output);

			internal static vxuLaplacianReconstruct pvxuLaplacianReconstruct;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAccumulateImage(Context context, Image input, Image accum);

			internal static vxuAccumulateImage pvxuAccumulateImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAccumulateWeightedImage(Context context, Image input, Scalar alpha, Image accum);

			internal static vxuAccumulateWeightedImage pvxuAccumulateWeightedImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAccumulateSquareImage(Context context, Image input, Scalar shift, Image accum);

			internal static vxuAccumulateSquareImage pvxuAccumulateSquareImage;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMinMaxLoc(Context context, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount);

			internal static vxuMinMaxLoc pvxuMinMaxLoc;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMin(Context context, Image in1, Image in2, Image @out);

			internal static vxuMin pvxuMin;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMax(Context context, Image in1, Image in2, Image @out);

			internal static vxuMax pvxuMax;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuConvertDepth(Context context, Image input, Image output, int policy, int shift);

			internal static vxuConvertDepth pvxuConvertDepth;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuCannyEdgeDetector(Context context, Image input, Threshold hyst, int gradient_size, int norm_type, Image output);

			internal static vxuCannyEdgeDetector pvxuCannyEdgeDetector;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHalfScaleGaussian(Context context, Image input, Image output, int kernel_size);

			internal static vxuHalfScaleGaussian pvxuHalfScaleGaussian;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAnd(Context context, Image in1, Image in2, Image @out);

			internal static vxuAnd pvxuAnd;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuOr(Context context, Image in1, Image in2, Image @out);

			internal static vxuOr pvxuOr;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuXor(Context context, Image in1, Image in2, Image @out);

			internal static vxuXor pvxuXor;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuNot(Context context, Image input, Image output);

			internal static vxuNot pvxuNot;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMultiply(Context context, Image in1, Image in2, float scale, int overflow_policy, int rounding_policy, Image @out);

			internal static vxuMultiply pvxuMultiply;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuAdd(Context context, Image in1, Image in2, int policy, Image @out);

			internal static vxuAdd pvxuAdd;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuSubtract(Context context, Image in1, Image in2, int policy, Image @out);

			internal static vxuSubtract pvxuSubtract;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuWarpAffine(Context context, Image input, Matrix matrix, int type, Image output);

			internal static vxuWarpAffine pvxuWarpAffine;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuWarpPerspective(Context context, Image input, Matrix matrix, int type, Image output);

			internal static vxuWarpPerspective pvxuWarpPerspective;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHarrisCorners(Context context, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners);

			internal static vxuHarrisCorners pvxuHarrisCorners;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuFastCorners(Context context, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners);

			internal static vxuFastCorners pvxuFastCorners;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuOpticalFlowPyrLK(Context context, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, int termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, UIntPtr window_dimension);

			internal static vxuOpticalFlowPyrLK pvxuOpticalFlowPyrLK;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMatchTemplateNode(Context context, Image src, Image templateImage, int matchingMethod, Image output);

			internal static vxuMatchTemplateNode pvxuMatchTemplateNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuLBPNode(Context context, Image @in, int format, sbyte kernel_size, Image @out);

			internal static vxuLBPNode pvxuLBPNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHOGFeatures(Context context, Image input, Tensor magnitudes, Tensor bins, Hog* @params, UIntPtr hog_param_size, Tensor features);

			internal static vxuHOGFeatures pvxuHOGFeatures;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHOGCells(Context context, Image input, int cell_size, int num_bins, Tensor magnitudes, Tensor bins);

			internal static vxuHOGCells pvxuHOGCells;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuHoughLinesPNode(Context context, Image input, HoughLinesParams* @params, Array lines_array, Scalar num_lines);

			internal static vxuHoughLinesPNode pvxuHoughLinesPNode;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuRemap(Context context, Image input, Remap table, int policy, Image output);

			internal static vxuRemap pvxuRemap;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuBilateralFilter(Context context, Tensor src, int diameter, float sigmaSpace, float sigmaValues, Tensor dst);

			internal static vxuBilateralFilter pvxuBilateralFilter;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorMultiply(Context context, Tensor input1, Tensor input2, Scalar scale, int overflow_policy, int rounding_policy, Tensor output);

			internal static vxuTensorMultiply pvxuTensorMultiply;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorAdd(Context context, Tensor input1, Tensor input2, int policy, Tensor output);

			internal static vxuTensorAdd pvxuTensorAdd;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorSubtract(Context context, Tensor input1, Tensor input2, int policy, Tensor output);

			internal static vxuTensorSubtract pvxuTensorSubtract;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorTableLookup(Context context, Tensor input1, Lut lut, Tensor output);

			internal static vxuTensorTableLookup pvxuTensorTableLookup;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorTranspose(Context context, Tensor input, Tensor output, UIntPtr dimension1, UIntPtr dimension2);

			internal static vxuTensorTranspose pvxuTensorTranspose;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuTensorConvertDepth(Context context, Tensor input, int policy, Scalar norm, Scalar offset, Tensor output);

			internal static vxuTensorConvertDepth pvxuTensorConvertDepth;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuMatrixMultiply(Context context, Tensor input1, Tensor input2, Tensor input3, MatrixMulParams* matrix_multiply_params, Tensor output);

			internal static vxuMatrixMultiply pvxuMatrixMultiply;

			[SuppressUnmanagedCodeSecurity]
			internal delegate Status vxuCopy(Context context, Reference input, Reference output);

			internal static vxuCopy pvxuCopy;

		}
	}

}


// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

// ReSharper disable RedundantUsingDirective
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable JoinDeclarationAndInitializer

namespace OpenGL
{
	public partial class Egl
	{
		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired size of the alpha component 
		/// of the color buffer, in bits. If this value is zero, color buffers with the smallest alpha component size are preferred. 
		/// Otherwise, color buffers with the largest alpha component of at least the specified size are preferred. The default 
		/// value is zero.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits of alpha stored in the color buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int ALPHA_SIZE = 0x3021;

		/// <summary>
		/// [EGL] Egl.GetError: EGL cannot access a requested resource (for example a context is bound in another thread).
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_ACCESS = 0x3002;

		/// <summary>
		/// [EGL] Egl.GetError: EGL failed to allocate resources for the requested operation.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_ALLOC = 0x3003;

		/// <summary>
		/// [EGL] Egl.GetError: An unrecognized attribute or attribute value was passed in the attribute list.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_ATTRIBUTE = 0x3004;

		/// <summary>
		/// [EGL] Egl.GetError: An EGLConfig argument does not name a valid EGL frame buffer configuration.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_CONFIG = 0x3005;

		/// <summary>
		/// [EGL] Egl.GetError: An EGLContext argument does not name a valid EGL rendering context.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_CONTEXT = 0x3006;

		/// <summary>
		/// [EGL] Egl.GetError: The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer 
		/// valid.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_CURRENT_SURFACE = 0x3007;

		/// <summary>
		/// [EGL] Egl.GetError: An EGLDisplay argument does not name a valid EGL display connection.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_DISPLAY = 0x3008;

		/// <summary>
		/// [EGL] Egl.GetError: Arguments are inconsistent (for example, a valid context requires buffers not supplied by a valid 
		/// surface).
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_MATCH = 0x3009;

		/// <summary>
		/// [EGL] Egl.GetError: A NativePixmapType argument does not refer to a valid native pixmap.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_NATIVE_PIXMAP = 0x300A;

		/// <summary>
		/// [EGL] Egl.GetError: A NativeWindowType argument does not refer to a valid native window.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_NATIVE_WINDOW = 0x300B;

		/// <summary>
		/// [EGL] Egl.GetError: One or more argument values are invalid.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_PARAMETER = 0x300C;

		/// <summary>
		/// [EGL] Egl.GetError: An EGLSurface argument does not name a valid surface (window, pixel buffer or pixmap) configured for 
		/// GL rendering.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BAD_SURFACE = 0x300D;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired size of the blue component 
		/// of the color buffer, in bits. If this value is zero, color buffers with the smallest blue component size are preferred. 
		/// Otherwise, color buffers with the largest blue component of at least the specified size are preferred. The default value 
		/// is zero.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits of blue stored in the color buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BLUE_SIZE = 0x3022;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired color buffer size, in bits. 
		/// The smallest color buffers of at least the specified size are preferred. The default value is zero. The color buffer 
		/// size is the sum of Egl.RED_SIZE, Egl.GREEN_SIZE, Egl.BLUE_SIZE, and Egl.ALPHA_SIZE, and does not include any padding 
		/// bits which may be present in the pixel format. It is usually preferable to specify desired sizes for these color 
		/// components individually.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the depth of the color buffer. It is the sum of Egl.RED_SIZE, Egl.GREEN_SIZE, 
		/// Egl.BLUE_SIZE, and Egl.ALPHA_SIZE.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int BUFFER_SIZE = 0x3020;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by Egl.DONT_CARE, Egl.NONE, Egl.SLOW_CONFIG, or Egl.NON_CONFORMANT_CONFIG. If 
		/// Egl.DONT_CARE is specified, then configs are not matched for this attribute. The default value is Egl.DONT_CARE. If 
		/// Egl.NONE is specified, then configs are matched for this attribute, but only configs with no caveats (neither 
		/// Egl.SLOW_CONFIG or Egl.NON_CONFORMANT_CONFIG) will be considered. If Egl.SLOW_CONFIG is specified, then only slow 
		/// configs configurations will be considered. The meaning of``slow'' is implementation-dependent, but typically indicates a 
		/// non-hardware-accelerated (software) implementation. If Egl.NON_CONFORMANT_CONFIG is specified, then only configs 
		/// supporting non-conformant OpenGL ES contexts will be considered. If the EGL version is 1.3 or later, caveat 
		/// Egl.NON_CONFORMANT_CONFIG is obsolete, since the same information can be specified via the Egl.CONFORMANT attribute on a 
		/// per-client-API basis, not just for OpenGL ES.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the caveats for the frame buffer configuration. Possible caveat values are Egl.NONE, 
		/// Egl.SLOW_CONFIG, and Egl.NON_CONFORMANT.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int CONFIG_CAVEAT = 0x3027;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a valid integer ID that indicates the desired EGL frame buffer 
		/// configuration. When a Egl.CONFIG_ID is specified, all other attributes are ignored. The default value is Egl.DONT_CARE. 
		/// The meaning of config IDs is implementation-dependent. They are used only to uniquely identify different frame buffer 
		/// configurations.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the ID of the frame buffer configuration.
		/// </para>
		/// <para>
		/// [EGL] Egl.QueryContext: Returns the ID of the EGL frame buffer configuration with respect to which the context was 
		/// created.
		/// </para>
		/// <para>
		/// [EGL] Egl.QuerySurface: Returns the ID of the EGL frame buffer configuration with respect to which the surface was 
		/// created.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int CONFIG_ID = 0x3028;

		/// <summary>
		/// [EGL] Value of EGL_CORE_NATIVE_ENGINE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int CORE_NATIVE_ENGINE = 0x305B;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired depth buffer size, in bits. 
		/// The smallest depth buffers of at least the specified size is preferred. If the desired size is zero, frame buffer 
		/// configurations with no depth buffer are preferred. The default value is zero. The depth buffer is used only by OpenGL 
		/// and OpenGL ES client APIs.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits in the depth buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int DEPTH_SIZE = 0x3025;

		/// <summary>
		/// [EGL] Value of EGL_DONT_CARE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int DONT_CARE = -1;

		/// <summary>
		/// [EGL] Value of EGL_DRAW symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int DRAW = 0x3059;

		/// <summary>
		/// [EGL] Egl.QueryString: Returns a space separated list of supported extensions to EGL.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int EXTENSIONS = 0x3055;

		/// <summary>
		/// [EGL] Value of EGL_FALSE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int FALSE = 0;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired size of the green component 
		/// of the color buffer, in bits. If this value is zero, color buffers with the smallest green component size are preferred. 
		/// Otherwise, color buffers with the largest green component of at least the specified size are preferred. The default 
		/// value is zero.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits of green stored in the color buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int GREEN_SIZE = 0x3023;

		/// <summary>
		/// <para>
		/// [EGL] Egl.CreatePbufferSurface: Specifies the required height of the pixel buffer surface. The default value is Egl..
		/// </para>
		/// <para>
		/// [EGL] Egl.QuerySurface: Returns the height of the surface in pixels.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int HEIGHT = 0x3056;

		/// <summary>
		/// <para>
		/// [EGL] Egl.CreatePbufferSurface: Requests the largest available pixel buffer surface when the allocation would otherwise 
		/// fail. Use Egl.QuerySurface to retrieve the dimensions of the allocated pixel buffer. The default value is Egl.FALSE.
		/// </para>
		/// <para>
		/// [EGL] Egl.QuerySurface: Returns the same attribute value specified when the surface was created with 
		/// Egl.CreatePbufferSurface. For a window or pixmap surface, value is not modified.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int LARGEST_PBUFFER = 0x3058;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by an integer buffer level specification. This specification is honored 
		/// exactly. Buffer level zero corresponds to the default frame buffer of the display. Buffer level one is the first overlay 
		/// frame buffer, level two the second overlay frame buffer, and so on. Negative buffer levels correspond to underlay frame 
		/// buffers. The default value is zero. Most imlementations do not support overlay or underlay planes (buffer levels other 
		/// than zero).
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the frame buffer level. Level zero is the default frame buffer. Positive levels 
		/// correspond to frame buffers that overlay the default buffer and negative levels correspond to frame buffers that 
		/// underlay the default buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int LEVEL = 0x3029;

		/// <summary>
		/// [EGL] Egl.GetConfigAttrib: Returns the maximum height of a pixel buffer surface in pixels.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int MAX_PBUFFER_HEIGHT = 0x302A;

		/// <summary>
		/// [EGL] Egl.GetConfigAttrib: Returns the maximum size of a pixel buffer surface in pixels.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int MAX_PBUFFER_PIXELS = 0x302B;

		/// <summary>
		/// [EGL] Egl.GetConfigAttrib: Returns the maximum width of a pixel buffer surface in pixels.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int MAX_PBUFFER_WIDTH = 0x302C;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by Egl.DONT_CARE, Egl.TRUE, or Egl.FALSE. If Egl.TRUE is specified, then only 
		/// frame buffer configurations that allow native rendering into the surface will be considered. The default value is 
		/// Egl.DONT_CARE.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns Egl.TRUE if native rendering APIs can render into the surface, Egl.FALSE otherwise.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NATIVE_RENDERABLE = 0x302D;

		/// <summary>
		/// [EGL] Egl.GetConfigAttrib: Returns the ID of the associated native visual.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NATIVE_VISUAL_ID = 0x302E;

		/// <summary>
		/// [EGL] Egl.GetConfigAttrib: Returns the type of the associated native visual.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NATIVE_VISUAL_TYPE = 0x302F;

		/// <summary>
		/// [EGL] Value of EGL_NONE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NONE = 0x3038;

		/// <summary>
		/// [EGL] Value of EGL_NON_CONFORMANT_CONFIG symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NON_CONFORMANT_CONFIG = 0x3051;

		/// <summary>
		/// [EGL] Egl.GetError: EGL is not initialized, or could not be initialized, for the specified EGL display connection.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NOT_INITIALIZED = 0x3001;

		/// <summary>
		/// [EGL] Value of EGL_NO_CONTEXT symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NO_CONTEXT = 0;

		/// <summary>
		/// [EGL] Value of EGL_NO_DISPLAY symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NO_DISPLAY = 0;

		/// <summary>
		/// [EGL] Value of EGL_NO_SURFACE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int NO_SURFACE = 0;

		/// <summary>
		/// [EGL] Value of EGL_PBUFFER_BIT symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		[Log(BitmaskName = "EGLSurfaceTypeMask")]
		public const int PBUFFER_BIT = 0x0001;

		/// <summary>
		/// [EGL] Value of EGL_PIXMAP_BIT symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		[Log(BitmaskName = "EGLSurfaceTypeMask")]
		public const int PIXMAP_BIT = 0x0002;

		/// <summary>
		/// [EGL] Value of EGL_READ symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int READ = 0x305A;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired size of the red component 
		/// of the color buffer, in bits. If this value is zero, color buffers with the smallest red component size are preferred. 
		/// Otherwise, color buffers with the largest red component of at least the specified size are preferred. The default value 
		/// is zero.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits of red stored in the color buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int RED_SIZE = 0x3024;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by the minimum number of samples required in multisample buffers. 
		/// Configurations with the smallest number of samples that meet or exceed the specified minimum number are preferred. Note 
		/// that it is possible for color samples in the multisample buffer to have fewer bits than colors in the main color 
		/// buffers. However, multisampled colors maintain at least as much color resolution in aggregate as the main color buffers.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of samples per pixel.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int SAMPLES = 0x3031;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by the minimum acceptable number of multisample buffers. Configurations with 
		/// the smallest number of multisample buffers that meet or exceed this minimum number are preferred. Currently operation 
		/// with more than one multisample buffer is undefined, so only values of zero or one will produce a match. The default 
		/// value is zero.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of multisample buffers.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int SAMPLE_BUFFERS = 0x3032;

		/// <summary>
		/// [EGL] Value of EGL_SLOW_CONFIG symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int SLOW_CONFIG = 0x3050;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a nonnegative integer that indicates the desired stencil buffer size, in 
		/// bits. The smallest stencil buffers of at least the specified size are preferred. If the desired size is zero, frame 
		/// buffer configurations with no stencil buffer are preferred. The default value is zero. The stencil buffer is used only 
		/// by OpenGL and OpenGL ES client APIs.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the number of bits in the stencil buffer.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int STENCIL_SIZE = 0x3026;

		/// <summary>
		/// [EGL] Egl.GetError: The last function succeeded without error.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int SUCCESS = 0x3000;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by a bitmask indicating which EGL surface types and capabilities the frame 
		/// buffer configuration must support. Mask bits include: Egl.MULTISAMPLE_RESOLVE_BOX_BIT Config allows specifying box 
		/// filtered multisample resolve behavior with Egl.SurfaceAttrib. Egl.PBUFFER_BIT Config supports creating pixel buffer 
		/// surfaces. Egl.PIXMAP_BIT Config supports creating pixmap surfaces. Egl.SWAP_BEHAVIOR_PRESERVED_BIT Config allows setting 
		/// swap behavior for color buffers with Egl.SurfaceAttrib. Egl.VG_ALPHA_FORMAT_PRE_BIT Config allows specifying OpenVG 
		/// rendering with premultiplied alpha values at surface creation time (see Egl.CreatePbufferSurface, 
		/// Egl.CreatePixmapSurface, and Egl.CreateWindowSurface). Egl.VG_COLORSPACE_LINEAR_BIT Config allows specifying OpenVG 
		/// rendering in a linear colorspace at surface creation time (see Egl.CreatePbufferSurface, Egl.CreatePixmapSurface, and 
		/// Egl.CreateWindowSurface). Egl.WINDOW_BIT Config supports creating window surfaces. For example, if the bitmask is set to 
		/// Egl.WINDOW_BIT | Egl.PIXMAP_BIT, only frame buffer configurations that support both windows and pixmaps will be 
		/// considered. The default value is Egl.WINDOW_BIT.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns a bitmask indicating the types of supported EGL surfaces.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int SURFACE_TYPE = 0x3033;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by an integer value indicating the transparent blue value. The value must be 
		/// between zero and the maximum color buffer value for blue. Only frame buffer configurations that use the specified 
		/// transparent blue value will be considered. The default value is Egl.DONT_CARE. This attribute is ignored unless 
		/// Egl.TRANSPARENT_TYPE is included in attrib_list and specified as Egl.TRANSPARENT_RGB.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the transparent blue value.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRANSPARENT_BLUE_VALUE = 0x3035;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by an integer value indicating the transparent green value. The value must be 
		/// between zero and the maximum color buffer value for green. Only frame buffer configurations that use the specified 
		/// transparent green value will be considered. The default value is Egl.DONT_CARE. This attribute is ignored unless 
		/// Egl.TRANSPARENT_TYPE is included in attrib_list and specified as Egl.TRANSPARENT_RGB.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the transparent green value.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRANSPARENT_GREEN_VALUE = 0x3036;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by an integer value indicating the transparent red value. The value must be 
		/// between zero and the maximum color buffer value for red. Only frame buffer configurations that use the specified 
		/// transparent red value will be considered. The default value is Egl.DONT_CARE. This attribute is ignored unless 
		/// Egl.TRANSPARENT_TYPE is included in attrib_list and specified as Egl.TRANSPARENT_RGB.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the transparent red value.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRANSPARENT_RED_VALUE = 0x3037;

		/// <summary>
		/// [EGL] Value of EGL_TRANSPARENT_RGB symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRANSPARENT_RGB = 0x3052;

		/// <summary>
		/// <para>
		/// [EGL] Egl.ChooseConfig: Must be followed by one of Egl.NONE or Egl.TRANSPARENT_RGB. If Egl.NONE is specified, then only 
		/// opaque frame buffer configurations will be considered. If Egl.TRANSPARENT_RGB is specified, then only transparent frame 
		/// buffer configurations will be considered. The default value is Egl.NONE. Most implementations support only opaque frame 
		/// buffer configurations.
		/// </para>
		/// <para>
		/// [EGL] Egl.GetConfigAttrib: Returns the type of supported transparency. Possible transparency values are: Egl.NONE, and 
		/// Egl.TRANSPARENT_RGB.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRANSPARENT_TYPE = 0x3034;

		/// <summary>
		/// [EGL] Value of EGL_TRUE symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int TRUE = 1;

		/// <summary>
		/// [EGL] Egl.QueryString: Returns the company responsible for this EGL implementation. This name does not change from 
		/// release to release.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int VENDOR = 0x3053;

		/// <summary>
		/// [EGL] Egl.QueryString: Returns a version or release number. The Egl.VERSION string is laid out as 
		/// follows:major_version.minor_version space vendor_specific_info
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int VERSION = 0x3054;

		/// <summary>
		/// <para>
		/// [EGL] Egl.CreatePbufferSurface: Specifies the required width of the pixel buffer surface. The default value is Egl..
		/// </para>
		/// <para>
		/// [EGL] Egl.QuerySurface: Returns the width of the surface in pixels.
		/// </para>
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public const int WIDTH = 0x3057;

		/// <summary>
		/// [EGL] Value of EGL_WINDOW_BIT symbol.
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		[Log(BitmaskName = "EGLSurfaceTypeMask")]
		public const int WINDOW_BIT = 0x0004;

		/// <summary>
		/// [EGL] eglChooseConfig: return a list of EGL frame buffer configurations that match specified attributes
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="attrib_list">
		/// Specifies attributes required to match by configs.
		/// </param>
		/// <param name="configs">
		/// Returns an array of frame buffer configurations.
		/// </param>
		/// <param name="config_size">
		/// Specifies the size of the array of frame buffer configurations.
		/// </param>
		/// <param name="num_config">
		/// Returns the number of frame buffer configurations returned.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool ChooseConfig(IntPtr dpy, int[] attrib_list, IntPtr[] configs, int config_size, int[] num_config)
		{
			bool retValue;

			unsafe {
				fixed (int* p_attrib_list = attrib_list)
				fixed (IntPtr* p_configs = configs)
				fixed (int* p_num_config = num_config)
				{
					Debug.Assert(Delegates.peglChooseConfig != null, "peglChooseConfig not implemented");
					retValue = Delegates.peglChooseConfig(dpy, p_attrib_list, p_configs, config_size, p_num_config);
					LogCommand("eglChooseConfig", retValue, dpy, attrib_list, configs, config_size, num_config					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglCopyBuffers: copy EGL surface color buffer to a native pixmap
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="surface">
		/// Specifies the EGL surface whose color buffer is to be copied.
		/// </param>
		/// <param name="target">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool CopyBuffers(IntPtr dpy, IntPtr surface, IntPtr target)
		{
			bool retValue;

			Debug.Assert(Delegates.peglCopyBuffers != null, "peglCopyBuffers not implemented");
			retValue = Delegates.peglCopyBuffers(dpy, surface, target);
			LogCommand("eglCopyBuffers", retValue, dpy, surface, target			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglCreateContext: create a new EGL rendering context
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration that defines the frame buffer resource available to the rendering context.
		/// </param>
		/// <param name="share_context">
		/// Specifies another EGL rendering context with which to share data, as defined by the client API corresponding to the 
		/// contexts. Data is also shared with all other contexts with which <paramref name="share_context"/> shares data. 
		/// Egl.NO_CONTEXT indicates that no sharing is to take place.
		/// </param>
		/// <param name="attrib_list">
		/// Specifies attributes and attribute values for the context being created. Only the attribute Egl.CONTEXT_CLIENT_VERSION 
		/// may be specified.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr CreateContext(IntPtr dpy, IntPtr config, IntPtr share_context, int[] attrib_list)
		{
			IntPtr retValue;

			unsafe {
				fixed (int* p_attrib_list = attrib_list)
				{
					Debug.Assert(Delegates.peglCreateContext != null, "peglCreateContext not implemented");
					retValue = Delegates.peglCreateContext(dpy, config, share_context, p_attrib_list);
					LogCommand("eglCreateContext", retValue, dpy, config, share_context, attrib_list					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglCreatePbufferSurface: create a new EGL pixel buffer surface
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration that defines the frame buffer resource available to the surface.
		/// </param>
		/// <param name="attrib_list">
		/// Specifies pixel buffer surface attributes. May be Egl. or empty (first attribute is Egl.NONE).
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr CreatePbufferSurface(IntPtr dpy, IntPtr config, int[] attrib_list)
		{
			IntPtr retValue;

			unsafe {
				fixed (int* p_attrib_list = attrib_list)
				{
					Debug.Assert(Delegates.peglCreatePbufferSurface != null, "peglCreatePbufferSurface not implemented");
					retValue = Delegates.peglCreatePbufferSurface(dpy, config, p_attrib_list);
					LogCommand("eglCreatePbufferSurface", retValue, dpy, config, attrib_list					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglCreatePixmapSurface: create a new EGL pixmap surface
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration that defines the frame buffer resource available to the surface.
		/// </param>
		/// <param name="pixmap">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="attrib_list">
		/// Specifies pixmap surface attributes. May be Egl. or empty (first attribute is Egl.NONE).
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr CreatePixmapSurface(IntPtr dpy, IntPtr config, IntPtr pixmap, int[] attrib_list)
		{
			IntPtr retValue;

			unsafe {
				fixed (int* p_attrib_list = attrib_list)
				{
					Debug.Assert(Delegates.peglCreatePixmapSurface != null, "peglCreatePixmapSurface not implemented");
					retValue = Delegates.peglCreatePixmapSurface(dpy, config, pixmap, p_attrib_list);
					LogCommand("eglCreatePixmapSurface", retValue, dpy, config, pixmap, attrib_list					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglCreateWindowSurface: create a new EGL window surface
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration that defines the frame buffer resource available to the surface.
		/// </param>
		/// <param name="win">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="attrib_list">
		/// Specifies window surface attributes. May be Egl. or empty (first attribute is Egl.NONE).
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr CreateWindowSurface(IntPtr dpy, IntPtr config, IntPtr win, int[] attrib_list)
		{
			IntPtr retValue;

			unsafe {
				fixed (int* p_attrib_list = attrib_list)
				{
					Debug.Assert(Delegates.peglCreateWindowSurface != null, "peglCreateWindowSurface not implemented");
					retValue = Delegates.peglCreateWindowSurface(dpy, config, win, p_attrib_list);
					LogCommand("eglCreateWindowSurface", retValue, dpy, config, win, attrib_list					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglDestroyContext: destroy an EGL rendering context
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="ctx">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool DestroyContext(IntPtr dpy, IntPtr ctx)
		{
			bool retValue;

			Debug.Assert(Delegates.peglDestroyContext != null, "peglDestroyContext not implemented");
			retValue = Delegates.peglDestroyContext(dpy, ctx);
			LogCommand("eglDestroyContext", retValue, dpy, ctx			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglDestroySurface: destroy an EGL surface
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="surface">
		/// Specifies the EGL surface to be destroyed.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool DestroySurface(IntPtr dpy, IntPtr surface)
		{
			bool retValue;

			Debug.Assert(Delegates.peglDestroySurface != null, "peglDestroySurface not implemented");
			retValue = Delegates.peglDestroySurface(dpy, surface);
			LogCommand("eglDestroySurface", retValue, dpy, surface			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetConfigAttrib: return information about an EGL frame buffer configuration
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration to be queried.
		/// </param>
		/// <param name="attribute">
		/// Specifies the EGL rendering context attribute to be returned.
		/// </param>
		/// <param name="value">
		/// Returns the requested value.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool GetConfigAttrib(IntPtr dpy, IntPtr config, int attribute, [Out] int[] value)
		{
			bool retValue;

			unsafe {
				fixed (int* p_value = value)
				{
					Debug.Assert(Delegates.peglGetConfigAttrib != null, "peglGetConfigAttrib not implemented");
					retValue = Delegates.peglGetConfigAttrib(dpy, config, attribute, p_value);
					LogCommand("eglGetConfigAttrib", retValue, dpy, config, attribute, value					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetConfigAttrib: return information about an EGL frame buffer configuration
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="config">
		/// Specifies the EGL frame buffer configuration to be queried.
		/// </param>
		/// <param name="attribute">
		/// Specifies the EGL rendering context attribute to be returned.
		/// </param>
		/// <param name="value">
		/// Returns the requested value.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool GetConfigAttrib(IntPtr dpy, IntPtr config, int attribute, out int value)
		{
			bool retValue;

			unsafe {
				fixed (int* p_value = &value)
				{
					Debug.Assert(Delegates.peglGetConfigAttrib != null, "peglGetConfigAttrib not implemented");
					retValue = Delegates.peglGetConfigAttrib(dpy, config, attribute, p_value);
					LogCommand("eglGetConfigAttrib", retValue, dpy, config, attribute, value					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetConfigs: return a list of all EGL frame buffer configurations for a display
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="configs">
		/// Returns a list of configs.
		/// </param>
		/// <param name="config_size">
		/// Specifies the size of the list of configs.
		/// </param>
		/// <param name="num_config">
		/// Returns the number of configs returned.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool GetConfigs(IntPtr dpy, [Out] IntPtr[] configs, int config_size, [Out] int[] num_config)
		{
			bool retValue;

			unsafe {
				fixed (IntPtr* p_configs = configs)
				fixed (int* p_num_config = num_config)
				{
					Debug.Assert(Delegates.peglGetConfigs != null, "peglGetConfigs not implemented");
					retValue = Delegates.peglGetConfigs(dpy, p_configs, config_size, p_num_config);
					LogCommand("eglGetConfigs", retValue, dpy, configs, config_size, num_config					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetConfigs: return a list of all EGL frame buffer configurations for a display
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="configs">
		/// Returns a list of configs.
		/// </param>
		/// <param name="config_size">
		/// Specifies the size of the list of configs.
		/// </param>
		/// <param name="num_config">
		/// Returns the number of configs returned.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool GetConfigs(IntPtr dpy, [Out] IntPtr[] configs, int config_size, out int num_config)
		{
			bool retValue;

			unsafe {
				fixed (IntPtr* p_configs = configs)
				fixed (int* p_num_config = &num_config)
				{
					Debug.Assert(Delegates.peglGetConfigs != null, "peglGetConfigs not implemented");
					retValue = Delegates.peglGetConfigs(dpy, p_configs, config_size, p_num_config);
					LogCommand("eglGetConfigs", retValue, dpy, configs, config_size, num_config					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetCurrentDisplay: return the display for the current EGL rendering context
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr GetCurrentDisplay()
		{
			IntPtr retValue;

			Debug.Assert(Delegates.peglGetCurrentDisplay != null, "peglGetCurrentDisplay not implemented");
			retValue = Delegates.peglGetCurrentDisplay();
			LogCommand("eglGetCurrentDisplay", retValue			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetCurrentSurface: return the read or draw surface for the current EGL rendering context
		/// </summary>
		/// <param name="readdraw">
		/// Specifies whether the EGL read or draw surface is to be returned.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr GetCurrentSurface(int readdraw)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.peglGetCurrentSurface != null, "peglGetCurrentSurface not implemented");
			retValue = Delegates.peglGetCurrentSurface(readdraw);
			LogCommand("eglGetCurrentSurface", retValue, readdraw			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetDisplay: return an EGL display connection
		/// </summary>
		/// <param name="display_id">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr GetDisplay(IntPtr display_id)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.peglGetDisplay != null, "peglGetDisplay not implemented");
			retValue = Delegates.peglGetDisplay(display_id);
			LogCommand("eglGetDisplay", retValue, display_id			);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetError: return error information
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static int GetError()
		{
			int retValue;

			Debug.Assert(Delegates.peglGetError != null, "peglGetError not implemented");
			retValue = Delegates.peglGetError();
			LogCommand("eglGetError", retValue			);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglGetProcAddress: return a GL or an EGL extension function
		/// </summary>
		/// <param name="procname">
		/// Specifies the name of the function to return.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static IntPtr GetProcAddress(string procname)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.peglGetProcAddress != null, "peglGetProcAddress not implemented");
			retValue = Delegates.peglGetProcAddress(procname);
			LogCommand("eglGetProcAddress", retValue, procname			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglInitialize: initialize an EGL display connection
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="major">
		/// Returns the major version number of the EGL implementation. May be Egl..
		/// </param>
		/// <param name="minor">
		/// Returns the minor version number of the EGL implementation. May be Egl..
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool Initialize(IntPtr dpy, int[] major, int[] minor)
		{
			bool retValue;

			unsafe {
				fixed (int* p_major = major)
				fixed (int* p_minor = minor)
				{
					Debug.Assert(Delegates.peglInitialize != null, "peglInitialize not implemented");
					retValue = Delegates.peglInitialize(dpy, p_major, p_minor);
					LogCommand("eglInitialize", retValue, dpy, major, minor					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglMakeCurrent: attach an EGL rendering context to EGL surfaces
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="draw">
		/// Specifies the EGL draw surface.
		/// </param>
		/// <param name="read">
		/// Specifies the EGL read surface.
		/// </param>
		/// <param name="ctx">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool MakeCurrent(IntPtr dpy, IntPtr draw, IntPtr read, IntPtr ctx)
		{
			bool retValue;

			Debug.Assert(Delegates.peglMakeCurrent != null, "peglMakeCurrent not implemented");
			retValue = Delegates.peglMakeCurrent(dpy, draw, read, ctx);
			LogCommand("eglMakeCurrent", retValue, dpy, draw, read, ctx			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglQueryContext: return EGL rendering context information
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="ctx">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="attribute">
		/// Specifies the EGL rendering context attribute to be returned.
		/// </param>
		/// <param name="value">
		/// Returns the requested value.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool QueryContext(IntPtr dpy, IntPtr ctx, int attribute, int[] value)
		{
			bool retValue;

			unsafe {
				fixed (int* p_value = value)
				{
					Debug.Assert(Delegates.peglQueryContext != null, "peglQueryContext not implemented");
					retValue = Delegates.peglQueryContext(dpy, ctx, attribute, p_value);
					LogCommand("eglQueryContext", retValue, dpy, ctx, attribute, value					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglQueryString: return a string describing an EGL display connection
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="name">
		/// Specifies a symbolic constant, one of Egl.CLIENT_APIS, Egl.VENDOR, Egl.VERSION, or Egl.EXTENSIONS.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static string QueryString(IntPtr dpy, int name)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.peglQueryString != null, "peglQueryString not implemented");
			retValue = Delegates.peglQueryString(dpy, name);
			LogCommand("eglQueryString", PtrToString(retValue), dpy, name			);
			DebugCheckErrors(retValue);

			return (PtrToString(retValue));
		}

		/// <summary>
		/// [EGL] eglQuerySurface: return EGL surface information
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="surface">
		/// Specifies the EGL surface to query.
		/// </param>
		/// <param name="attribute">
		/// Specifies the EGL surface attribute to be returned.
		/// </param>
		/// <param name="value">
		/// Returns the requested value.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool QuerySurface(IntPtr dpy, IntPtr surface, int attribute, int[] value)
		{
			bool retValue;

			unsafe {
				fixed (int* p_value = value)
				{
					Debug.Assert(Delegates.peglQuerySurface != null, "peglQuerySurface not implemented");
					retValue = Delegates.peglQuerySurface(dpy, surface, attribute, p_value);
					LogCommand("eglQuerySurface", retValue, dpy, surface, attribute, value					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglSwapBuffers: post EGL surface color buffer to a native window
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="surface">
		/// Specifies the EGL drawing surface whose buffers are to be swapped.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool SwapBuffers(IntPtr dpy, IntPtr surface)
		{
			bool retValue;

			Debug.Assert(Delegates.peglSwapBuffers != null, "peglSwapBuffers not implemented");
			retValue = Delegates.peglSwapBuffers(dpy, surface);
			LogCommand("eglSwapBuffers", retValue, dpy, surface			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglTerminate: terminate an EGL display connection
		/// </summary>
		/// <param name="dpy">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool Terminate(IntPtr dpy)
		{
			bool retValue;

			Debug.Assert(Delegates.peglTerminate != null, "peglTerminate not implemented");
			retValue = Delegates.peglTerminate(dpy);
			LogCommand("eglTerminate", retValue, dpy			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglWaitGL: Complete GL execution prior to subsequent native rendering calls
		/// </summary>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool WaitGL()
		{
			bool retValue;

			Debug.Assert(Delegates.peglWaitGL != null, "peglWaitGL not implemented");
			retValue = Delegates.peglWaitGL();
			LogCommand("eglWaitGL", retValue			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// [EGL] eglWaitNative: complete native execution prior to subsequent GL rendering calls
		/// </summary>
		/// <param name="engine">
		/// Specifies a particular marking engine to be waited on. Must be Egl.CORE_NATIVE_ENGINE.
		/// </param>
		[RequiredByFeature("EGL_VERSION_1_0")]
		public static bool WaitNative(int engine)
		{
			bool retValue;

			Debug.Assert(Delegates.peglWaitNative != null, "peglWaitNative not implemented");
			retValue = Delegates.peglWaitNative(engine);
			LogCommand("eglWaitNative", retValue, engine			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		internal static unsafe partial class Delegates
		{
			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglChooseConfig(IntPtr dpy, int* attrib_list, IntPtr* configs, int config_size, int* num_config);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglChooseConfig peglChooseConfig;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglCopyBuffers(IntPtr dpy, IntPtr surface, IntPtr target);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglCopyBuffers peglCopyBuffers;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglCreateContext(IntPtr dpy, IntPtr config, IntPtr share_context, int* attrib_list);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglCreateContext peglCreateContext;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglCreatePbufferSurface(IntPtr dpy, IntPtr config, int* attrib_list);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglCreatePbufferSurface peglCreatePbufferSurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglCreatePixmapSurface(IntPtr dpy, IntPtr config, IntPtr pixmap, int* attrib_list);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglCreatePixmapSurface peglCreatePixmapSurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglCreateWindowSurface(IntPtr dpy, IntPtr config, IntPtr win, int* attrib_list);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglCreateWindowSurface peglCreateWindowSurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglDestroyContext(IntPtr dpy, IntPtr ctx);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglDestroyContext peglDestroyContext;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglDestroySurface(IntPtr dpy, IntPtr surface);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglDestroySurface peglDestroySurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglGetConfigAttrib(IntPtr dpy, IntPtr config, int attribute, int* value);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetConfigAttrib peglGetConfigAttrib;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglGetConfigs(IntPtr dpy, IntPtr* configs, int config_size, int* num_config);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetConfigs peglGetConfigs;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglGetCurrentDisplay();

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetCurrentDisplay peglGetCurrentDisplay;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglGetCurrentSurface(int readdraw);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetCurrentSurface peglGetCurrentSurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglGetDisplay(IntPtr display_id);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetDisplay peglGetDisplay;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate int eglGetError();

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetError peglGetError;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglGetProcAddress(string procname);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglGetProcAddress peglGetProcAddress;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglInitialize(IntPtr dpy, int* major, int* minor);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglInitialize peglInitialize;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglMakeCurrent(IntPtr dpy, IntPtr draw, IntPtr read, IntPtr ctx);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglMakeCurrent peglMakeCurrent;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglQueryContext(IntPtr dpy, IntPtr ctx, int attribute, int* value);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglQueryContext peglQueryContext;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate IntPtr eglQueryString(IntPtr dpy, int name);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglQueryString peglQueryString;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglQuerySurface(IntPtr dpy, IntPtr surface, int attribute, int* value);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglQuerySurface peglQuerySurface;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglSwapBuffers(IntPtr dpy, IntPtr surface);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglSwapBuffers peglSwapBuffers;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglTerminate(IntPtr dpy);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglTerminate peglTerminate;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglWaitGL();

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglWaitGL peglWaitGL;

			[RequiredByFeature("EGL_VERSION_1_0")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate bool eglWaitNative(int engine);

			[RequiredByFeature("EGL_VERSION_1_0")]
			internal static eglWaitNative peglWaitNative;

		}
	}

}

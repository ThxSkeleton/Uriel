
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

// ReSharper disable RedundantUsingDirective
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable JoinDeclarationAndInitializer

namespace OpenGL
{
	public partial class Gl
	{
		/// <summary>
		/// [GL] glGetGraphicsResetStatusARB: Binding for glGetGraphicsResetStatusARB.
		/// </summary>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static GraphicsResetStatus GetGraphicsResetStatusARB()
		{
			int retValue;

			Debug.Assert(Delegates.pglGetGraphicsResetStatusARB != null, "pglGetGraphicsResetStatusARB not implemented");
			retValue = Delegates.pglGetGraphicsResetStatusARB();
			LogCommand("glGetGraphicsResetStatusARB", (GraphicsResetStatus)retValue			);
			DebugCheckErrors(retValue);

			return ((GraphicsResetStatus)retValue);
		}

		/// <summary>
		/// [GL] glGetnTexImageARB: Binding for glGetnTexImageARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:TextureTarget"/>.
		/// </param>
		/// <param name="level">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="img">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr img)
		{
			Debug.Assert(Delegates.pglGetnTexImageARB != null, "pglGetnTexImageARB not implemented");
			Delegates.pglGetnTexImageARB((int)target, level, (int)format, (int)type, bufSize, img);
			LogCommand("glGetnTexImageARB", null, target, level, format, type, bufSize, img			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnTexImageARB: Binding for glGetnTexImageARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:TextureTarget"/>.
		/// </param>
		/// <param name="level">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="img">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, object img)
		{
			GCHandle pin_img = GCHandle.Alloc(img, GCHandleType.Pinned);
			try {
				GetnTexImageARB(target, level, format, type, bufSize, pin_img.AddrOfPinnedObject());
			} finally {
				pin_img.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnCompressedTexImageARB: Binding for glGetnCompressedTexImageARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:TextureTarget"/>.
		/// </param>
		/// <param name="lod">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="img">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, IntPtr img)
		{
			Debug.Assert(Delegates.pglGetnCompressedTexImageARB != null, "pglGetnCompressedTexImageARB not implemented");
			Delegates.pglGetnCompressedTexImageARB((int)target, lod, bufSize, img);
			LogCommand("glGetnCompressedTexImageARB", null, target, lod, bufSize, img			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnCompressedTexImageARB: Binding for glGetnCompressedTexImageARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:TextureTarget"/>.
		/// </param>
		/// <param name="lod">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="img">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, object img)
		{
			GCHandle pin_img = GCHandle.Alloc(img, GCHandleType.Pinned);
			try {
				GetnCompressedTexImageARB(target, lod, bufSize, pin_img.AddrOfPinnedObject());
			} finally {
				pin_img.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnUniformfvARB: Binding for glGetnUniformfvARB.
		/// </summary>
		/// <param name="program">
		/// A <see cref="T:uint"/>.
		/// </param>
		/// <param name="location">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="params">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnUniformARB(uint program, int location, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetnUniformfvARB != null, "pglGetnUniformfvARB not implemented");
					Delegates.pglGetnUniformfvARB(program, location, @params.Length, p_params);
					LogCommand("glGetnUniformfvARB", null, program, location, @params.Length, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnUniformivARB: Binding for glGetnUniformivARB.
		/// </summary>
		/// <param name="program">
		/// A <see cref="T:uint"/>.
		/// </param>
		/// <param name="location">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="params">
		/// A <see cref="T:int[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnUniformARB(uint program, int location, [Out] int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetnUniformivARB != null, "pglGetnUniformivARB not implemented");
					Delegates.pglGetnUniformivARB(program, location, @params.Length, p_params);
					LogCommand("glGetnUniformivARB", null, program, location, @params.Length, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnUniformuivARB: Binding for glGetnUniformuivARB.
		/// </summary>
		/// <param name="program">
		/// A <see cref="T:uint"/>.
		/// </param>
		/// <param name="location">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="params">
		/// A <see cref="T:uint[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnUniformARB(uint program, int location, [Out] uint[] @params)
		{
			unsafe {
				fixed (uint* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetnUniformuivARB != null, "pglGetnUniformuivARB not implemented");
					Delegates.pglGetnUniformuivARB(program, location, @params.Length, p_params);
					LogCommand("glGetnUniformuivARB", null, program, location, @params.Length, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnUniformdvARB: Binding for glGetnUniformdvARB.
		/// </summary>
		/// <param name="program">
		/// A <see cref="T:uint"/>.
		/// </param>
		/// <param name="location">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="params">
		/// A <see cref="T:double[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
		public static void GetnUniformARB(uint program, int location, [Out] double[] @params)
		{
			unsafe {
				fixed (double* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetnUniformdvARB != null, "pglGetnUniformdvARB not implemented");
					Delegates.pglGetnUniformdvARB(program, location, @params.Length, p_params);
					LogCommand("glGetnUniformdvARB", null, program, location, @params.Length, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapdvARB: Binding for glGetnMapdvARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:double[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, int bufSize, [Out] double[] v)
		{
			unsafe {
				fixed (double* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapdvARB != null, "pglGetnMapdvARB not implemented");
					Delegates.pglGetnMapdvARB((int)target, (int)query, bufSize, p_v);
					LogCommand("glGetnMapdvARB", null, target, query, bufSize, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapdvARB: Binding for glGetnMapdvARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:double[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, [Out] double[] v)
		{
			unsafe {
				fixed (double* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapdvARB != null, "pglGetnMapdvARB not implemented");
					Delegates.pglGetnMapdvARB((int)target, (int)query, v.Length, p_v);
					LogCommand("glGetnMapdvARB", null, target, query, v.Length, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapfvARB: Binding for glGetnMapfvARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, int bufSize, [Out] float[] v)
		{
			unsafe {
				fixed (float* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapfvARB != null, "pglGetnMapfvARB not implemented");
					Delegates.pglGetnMapfvARB((int)target, (int)query, bufSize, p_v);
					LogCommand("glGetnMapfvARB", null, target, query, bufSize, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapfvARB: Binding for glGetnMapfvARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, [Out] float[] v)
		{
			unsafe {
				fixed (float* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapfvARB != null, "pglGetnMapfvARB not implemented");
					Delegates.pglGetnMapfvARB((int)target, (int)query, v.Length, p_v);
					LogCommand("glGetnMapfvARB", null, target, query, v.Length, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapivARB: Binding for glGetnMapivARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:int[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, int bufSize, [Out] int[] v)
		{
			unsafe {
				fixed (int* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapivARB != null, "pglGetnMapivARB not implemented");
					Delegates.pglGetnMapivARB((int)target, (int)query, bufSize, p_v);
					LogCommand("glGetnMapivARB", null, target, query, bufSize, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMapivARB: Binding for glGetnMapivARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MapTarget"/>.
		/// </param>
		/// <param name="query">
		/// A <see cref="T:MapQuery"/>.
		/// </param>
		/// <param name="v">
		/// A <see cref="T:int[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMapARB(MapTarget target, MapQuery query, [Out] int[] v)
		{
			unsafe {
				fixed (int* p_v = v)
				{
					Debug.Assert(Delegates.pglGetnMapivARB != null, "pglGetnMapivARB not implemented");
					Delegates.pglGetnMapivARB((int)target, (int)query, v.Length, p_v);
					LogCommand("glGetnMapivARB", null, target, query, v.Length, v					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapfvARB: Binding for glGetnPixelMapfvARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, int bufSize, [Out] float[] values)
		{
			unsafe {
				fixed (float* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapfvARB != null, "pglGetnPixelMapfvARB not implemented");
					Delegates.pglGetnPixelMapfvARB((int)map, bufSize, p_values);
					LogCommand("glGetnPixelMapfvARB", null, map, bufSize, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapfvARB: Binding for glGetnPixelMapfvARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, [Out] float[] values)
		{
			unsafe {
				fixed (float* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapfvARB != null, "pglGetnPixelMapfvARB not implemented");
					Delegates.pglGetnPixelMapfvARB((int)map, values.Length, p_values);
					LogCommand("glGetnPixelMapfvARB", null, map, values.Length, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapuivARB: Binding for glGetnPixelMapuivARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:uint[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, int bufSize, [Out] uint[] values)
		{
			unsafe {
				fixed (uint* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapuivARB != null, "pglGetnPixelMapuivARB not implemented");
					Delegates.pglGetnPixelMapuivARB((int)map, bufSize, p_values);
					LogCommand("glGetnPixelMapuivARB", null, map, bufSize, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapuivARB: Binding for glGetnPixelMapuivARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:uint[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, [Out] uint[] values)
		{
			unsafe {
				fixed (uint* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapuivARB != null, "pglGetnPixelMapuivARB not implemented");
					Delegates.pglGetnPixelMapuivARB((int)map, values.Length, p_values);
					LogCommand("glGetnPixelMapuivARB", null, map, values.Length, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapusvARB: Binding for glGetnPixelMapusvARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:ushort[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, int bufSize, [Out] ushort[] values)
		{
			unsafe {
				fixed (ushort* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapusvARB != null, "pglGetnPixelMapusvARB not implemented");
					Delegates.pglGetnPixelMapusvARB((int)map, bufSize, p_values);
					LogCommand("glGetnPixelMapusvARB", null, map, bufSize, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPixelMapusvARB: Binding for glGetnPixelMapusvARB.
		/// </summary>
		/// <param name="map">
		/// A <see cref="T:PixelMap"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:ushort[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPixelMapARB(PixelMap map, [Out] ushort[] values)
		{
			unsafe {
				fixed (ushort* p_values = values)
				{
					Debug.Assert(Delegates.pglGetnPixelMapusvARB != null, "pglGetnPixelMapusvARB not implemented");
					Delegates.pglGetnPixelMapusvARB((int)map, values.Length, p_values);
					LogCommand("glGetnPixelMapusvARB", null, map, values.Length, values					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnPolygonStippleARB: Binding for glGetnPolygonStippleARB.
		/// </summary>
		/// <param name="pattern">
		/// A <see cref="T:byte[]"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnPolygonStippleARB([Out] byte[] pattern)
		{
			unsafe {
				fixed (byte* p_pattern = pattern)
				{
					Debug.Assert(Delegates.pglGetnPolygonStippleARB != null, "pglGetnPolygonStippleARB not implemented");
					Delegates.pglGetnPolygonStippleARB(pattern.Length, p_pattern);
					LogCommand("glGetnPolygonStippleARB", null, pattern.Length, pattern					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnColorTableARB: Binding for glGetnColorTableARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:ColorTableTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="table">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr table)
		{
			Debug.Assert(Delegates.pglGetnColorTableARB != null, "pglGetnColorTableARB not implemented");
			Delegates.pglGetnColorTableARB((int)target, (int)format, (int)type, bufSize, table);
			LogCommand("glGetnColorTableARB", null, target, format, type, bufSize, table			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnColorTableARB: Binding for glGetnColorTableARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:ColorTableTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="table">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, object table)
		{
			GCHandle pin_table = GCHandle.Alloc(table, GCHandleType.Pinned);
			try {
				GetnColorTableARB(target, format, type, bufSize, pin_table.AddrOfPinnedObject());
			} finally {
				pin_table.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnConvolutionFilterARB: Binding for glGetnConvolutionFilterARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:ConvolutionTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="image">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr image)
		{
			Debug.Assert(Delegates.pglGetnConvolutionFilterARB != null, "pglGetnConvolutionFilterARB not implemented");
			Delegates.pglGetnConvolutionFilterARB((int)target, (int)format, (int)type, bufSize, image);
			LogCommand("glGetnConvolutionFilterARB", null, target, format, type, bufSize, image			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnConvolutionFilterARB: Binding for glGetnConvolutionFilterARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:ConvolutionTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="image">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, object image)
		{
			GCHandle pin_image = GCHandle.Alloc(image, GCHandleType.Pinned);
			try {
				GetnConvolutionFilterARB(target, format, type, bufSize, pin_image.AddrOfPinnedObject());
			} finally {
				pin_image.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnSeparableFilterARB: Binding for glGetnSeparableFilterARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:SeparableTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="rowBufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="row">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="columnBufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="column">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		/// <param name="span">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnSeparableFilterARB(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span)
		{
			Debug.Assert(Delegates.pglGetnSeparableFilterARB != null, "pglGetnSeparableFilterARB not implemented");
			Delegates.pglGetnSeparableFilterARB((int)target, (int)format, (int)type, rowBufSize, row, columnBufSize, column, span);
			LogCommand("glGetnSeparableFilterARB", null, target, format, type, rowBufSize, row, columnBufSize, column, span			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnSeparableFilterARB: Binding for glGetnSeparableFilterARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:SeparableTarget"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="rowBufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="row">
		/// A <see cref="T:object"/>.
		/// </param>
		/// <param name="columnBufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="column">
		/// A <see cref="T:object"/>.
		/// </param>
		/// <param name="span">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnSeparableFilterARB(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, object row, int columnBufSize, object column, object span)
		{
			GCHandle pin_row = GCHandle.Alloc(row, GCHandleType.Pinned);
			GCHandle pin_column = GCHandle.Alloc(column, GCHandleType.Pinned);
			GCHandle pin_span = GCHandle.Alloc(span, GCHandleType.Pinned);
			try {
				GetnSeparableFilterARB(target, format, type, rowBufSize, pin_row.AddrOfPinnedObject(), columnBufSize, pin_column.AddrOfPinnedObject(), pin_span.AddrOfPinnedObject());
			} finally {
				pin_row.Free();
				pin_column.Free();
				pin_span.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnHistogramARB: Binding for glGetnHistogramARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:HistogramTarget"/>.
		/// </param>
		/// <param name="reset">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnHistogramARB(HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
		{
			Debug.Assert(Delegates.pglGetnHistogramARB != null, "pglGetnHistogramARB not implemented");
			Delegates.pglGetnHistogramARB((int)target, reset, (int)format, (int)type, bufSize, values);
			LogCommand("glGetnHistogramARB", null, target, reset, format, type, bufSize, values			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnHistogramARB: Binding for glGetnHistogramARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:HistogramTarget"/>.
		/// </param>
		/// <param name="reset">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnHistogramARB(HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, object values)
		{
			GCHandle pin_values = GCHandle.Alloc(values, GCHandleType.Pinned);
			try {
				GetnHistogramARB(target, reset, format, type, bufSize, pin_values.AddrOfPinnedObject());
			} finally {
				pin_values.Free();
			}
		}

		/// <summary>
		/// [GL] glGetnMinmaxARB: Binding for glGetnMinmaxARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MinmaxTarget"/>.
		/// </param>
		/// <param name="reset">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:IntPtr"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMinmaxARB(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values)
		{
			Debug.Assert(Delegates.pglGetnMinmaxARB != null, "pglGetnMinmaxARB not implemented");
			Delegates.pglGetnMinmaxARB((int)target, reset, (int)format, (int)type, bufSize, values);
			LogCommand("glGetnMinmaxARB", null, target, reset, format, type, bufSize, values			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glGetnMinmaxARB: Binding for glGetnMinmaxARB.
		/// </summary>
		/// <param name="target">
		/// A <see cref="T:MinmaxTarget"/>.
		/// </param>
		/// <param name="reset">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="format">
		/// A <see cref="T:PixelFormat"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="bufSize">
		/// A <see cref="T:int"/>.
		/// </param>
		/// <param name="values">
		/// A <see cref="T:object"/>.
		/// </param>
		[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
		public static void GetnMinmaxARB(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, object values)
		{
			GCHandle pin_values = GCHandle.Alloc(values, GCHandleType.Pinned);
			try {
				GetnMinmaxARB(target, reset, format, type, bufSize, pin_values.AddrOfPinnedObject());
			} finally {
				pin_values.Free();
			}
		}

		internal static unsafe partial class Delegates
		{
			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate int glGetGraphicsResetStatusARB();

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetGraphicsResetStatusARB pglGetGraphicsResetStatusARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnTexImageARB(int target, int level, int format, int type, int bufSize, IntPtr img);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnTexImageARB pglGetnTexImageARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnCompressedTexImageARB(int target, int lod, int bufSize, IntPtr img);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnCompressedTexImageARB pglGetnCompressedTexImageARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnUniformfvARB(uint program, int location, int bufSize, float* @params);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnUniformfvARB pglGetnUniformfvARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnUniformivARB(uint program, int location, int bufSize, int* @params);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnUniformivARB pglGetnUniformivARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnUniformuivARB(uint program, int location, int bufSize, uint* @params);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnUniformuivARB pglGetnUniformuivARB;

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnUniformdvARB(uint program, int location, int bufSize, double* @params);

			[RequiredByFeature("GL_ARB_robustness", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetnUniformdvARB pglGetnUniformdvARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnMapdvARB(int target, int query, int bufSize, double* v);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnMapdvARB pglGetnMapdvARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnMapfvARB(int target, int query, int bufSize, float* v);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnMapfvARB pglGetnMapfvARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnMapivARB(int target, int query, int bufSize, int* v);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnMapivARB pglGetnMapivARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnPixelMapfvARB(int map, int bufSize, float* values);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnPixelMapfvARB pglGetnPixelMapfvARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnPixelMapuivARB(int map, int bufSize, uint* values);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnPixelMapuivARB pglGetnPixelMapuivARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnPixelMapusvARB(int map, int bufSize, ushort* values);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnPixelMapusvARB pglGetnPixelMapusvARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnPolygonStippleARB(int bufSize, byte* pattern);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnPolygonStippleARB pglGetnPolygonStippleARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnColorTableARB(int target, int format, int type, int bufSize, IntPtr table);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnColorTableARB pglGetnColorTableARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnConvolutionFilterARB(int target, int format, int type, int bufSize, IntPtr image);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnConvolutionFilterARB pglGetnConvolutionFilterARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnSeparableFilterARB(int target, int format, int type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnSeparableFilterARB pglGetnSeparableFilterARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnHistogramARB(int target, [MarshalAs(UnmanagedType.I1)] bool reset, int format, int type, int bufSize, IntPtr values);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnHistogramARB pglGetnHistogramARB;

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetnMinmaxARB(int target, [MarshalAs(UnmanagedType.I1)] bool reset, int format, int type, int bufSize, IntPtr values);

			[RequiredByFeature("GL_ARB_robustness", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetnMinmaxARB pglGetnMinmaxARB;

		}
	}

}


// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

// ReSharper disable RedundantUsingDirective
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable JoinDeclarationAndInitializer

namespace OpenGL
{
	public partial class Gl
	{
		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a 1D convolution operation on incoming RGBA color values. See 
		/// Gl.ConvolutionFilter1D.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether 1D convolution is enabled. The initial value is 
		/// Gl.FALSE. See Gl.ConvolutionFilter1D.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_1D = 0x8010;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a 2D convolution operation on incoming RGBA color values. See 
		/// Gl.ConvolutionFilter2D.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether 2D convolution is enabled. The initial value is 
		/// Gl.FALSE. See Gl.ConvolutionFilter2D.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_2D = 0x8011;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a two-dimensional convolution operation using a separable convolution filter on 
		/// incoming RGBA color values. See Gl.SeparableFilter2D.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether 2D separable convolution is enabled. The 
		/// initial value is Gl.FALSE. See Gl.SeparableFilter2D.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int SEPARABLE_2D = 0x8012;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The convolution border mode. See Gl.ConvolutionParameter for a list of border modes.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_BORDER_MODE = 0x8013;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current filter scale factors. params must be a pointer to an array of four 
		/// elements, which will receive the red, green, blue, and alpha filter scale factors in that order.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_FILTER_SCALE = 0x8014;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current filter bias factors. params must be a pointer to an array of four 
		/// elements, which will receive the red, green, blue, and alpha filter bias terms in that order.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_FILTER_BIAS = 0x8015;

		/// <summary>
		/// [GL2.1] Gl.ConvolutionParameter: The image resulting from convolution is smaller than the source image. If the filter 
		/// width is Wf and height is Hf, and the source image width is Ws and height is Hs, then the convolved image width will be 
		/// Ws-Wf+1 and height will be Hs-Hf+1. (If this reduction would generate an image with zero or negative width and/or 
		/// height, the output is simply null, with no error generated.) The coordinates of the image resulting from convolution are 
		/// zero through Ws-Wf in width and zero through Hs-Hf in height.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int REDUCE = 0x8016;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current internal format. See Gl.ConvolutionFilter1D, Gl.ConvolutionFilter2D, and 
		/// Gl.SeparableFilter2D for lists of allowable formats.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_FORMAT = 0x8017;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current filter image width.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_WIDTH = 0x8018;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current filter image height.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int CONVOLUTION_HEIGHT = 0x8019;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The maximum acceptable filter image width.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int MAX_CONVOLUTION_WIDTH = 0x801A;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The maximum acceptable filter image height.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int MAX_CONVOLUTION_HEIGHT = 0x801B;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the red scale factor applied to RGBA fragments after convolution. The initial 
		/// value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_RED_SCALE = 0x801C;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the green scale factor applied to RGBA fragments after convolution. The 
		/// initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_GREEN_SCALE = 0x801D;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the blue scale factor applied to RGBA fragments after convolution. The initial 
		/// value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_BLUE_SCALE = 0x801E;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the alpha scale factor applied to RGBA fragments after convolution. The 
		/// initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_ALPHA_SCALE = 0x801F;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the red bias factor applied to RGBA fragments after convolution. The initial 
		/// value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_RED_BIAS = 0x8020;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the green bias factor applied to RGBA fragments after convolution. The initial 
		/// value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_GREEN_BIAS = 0x8021;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the blue bias factor applied to RGBA fragments after convolution. The initial 
		/// value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_BLUE_BIAS = 0x8022;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the alpha bias factor applied to RGBA fragments after convolution. The initial 
		/// value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_convolution")]
		public const int POST_CONVOLUTION_ALPHA_BIAS = 0x8023;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, histogram incoming RGBA color values. See Gl.Histogram.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether histogram is enabled. The initial value is 
		/// Gl.FALSE. See Gl.Histogram.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM = 0x8024;

		/// <summary>
		/// [GL] Value of GL_PROXY_HISTOGRAM symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int PROXY_HISTOGRAM = 0x8025;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_WIDTH symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_WIDTH = 0x8026;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_FORMAT symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_FORMAT = 0x8027;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_RED_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_RED_SIZE = 0x8028;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_GREEN_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_GREEN_SIZE = 0x8029;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_BLUE_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_BLUE_SIZE = 0x802A;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_ALPHA_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_ALPHA_SIZE = 0x802B;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_LUMINANCE_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_LUMINANCE_SIZE = 0x802C;

		/// <summary>
		/// [GL] Value of GL_HISTOGRAM_SINK symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int HISTOGRAM_SINK = 0x802D;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, compute the minimum and maximum values of incoming RGBA color values. See Gl.Minmax.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether pixel minmax values are computed. The initial 
		/// value is Gl.FALSE. See Gl.Minmax.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int MINMAX = 0x802E;

		/// <summary>
		/// [GL] Value of GL_MINMAX_FORMAT symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int MINMAX_FORMAT = 0x802F;

		/// <summary>
		/// [GL] Value of GL_MINMAX_SINK symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int MINMAX_SINK = 0x8030;

		/// <summary>
		/// [GL2.1] Gl.GetError: The specified table exceeds the implementation's maximum supported table size. The offending 
		/// command is ignored and has no other side effect than to set the error flag.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_histogram")]
		public const int TABLE_TOO_LARGE = 0x8031;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns sixteen values: the color matrix on the top of the color matrix stack. Initially this 
		/// matrix is the identity matrix. See Gl.PushMatrix.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int COLOR_MATRIX = 0x80B1;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the maximum supported depth of the projection matrix stack. The value must be 
		/// at least 2. See Gl.PushMatrix.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int COLOR_MATRIX_STACK_DEPTH = 0x80B2;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the maximum supported depth of the color matrix stack. The value must be at 
		/// least 2. See Gl.PushMatrix.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the red scale factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_RED_SCALE = 0x80B4;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the green scale factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the blue scale factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the alpha scale factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 1. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the red bias factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_RED_BIAS = 0x80B8;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the green bias factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 0. See Gl.PixelTransfer
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the blue bias factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA;

		/// <summary>
		/// [GL2.1] Gl.Get: params returns one value, the alpha bias factor applied to RGBA fragments after color matrix 
		/// transformations. The initial value is 0. See Gl.PixelTransfer.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_matrix")]
		public const int POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a color table lookup on the incoming RGBA color values. See Gl.ColorTable.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether the color table lookup is enabled. See 
		/// Gl.ColorTable.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE = 0x80D0;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a color table lookup on RGBA color values after convolution. See Gl.ColorTable.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether post convolution lookup is enabled. The initial 
		/// value is Gl.FALSE. See Gl.ColorTable.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int POST_CONVOLUTION_COLOR_TABLE = 0x80D1;

		/// <summary>
		/// <para>
		/// [GL2.1] Gl.Enable: If enabled, perform a color table lookup on RGBA color values after color matrix transformation. See 
		/// Gl.ColorTable.
		/// </para>
		/// <para>
		/// [GL2.1] Gl.Get: params returns a single boolean value indicating whether post color matrix transformation lookup is 
		/// enabled. The initial value is Gl.FALSE. See Gl.ColorTable.
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2;

		/// <summary>
		/// [GL] Value of GL_PROXY_COLOR_TABLE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int PROXY_COLOR_TABLE = 0x80D3;

		/// <summary>
		/// [GL] Value of GL_PROXY_POST_CONVOLUTION_COLOR_TABLE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4;

		/// <summary>
		/// [GL] Value of GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_SCALE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_SCALE = 0x80D6;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_BIAS symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_BIAS = 0x80D7;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_FORMAT symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_FORMAT = 0x80D8;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_WIDTH symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_WIDTH = 0x80D9;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_RED_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_RED_SIZE = 0x80DA;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_GREEN_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_GREEN_SIZE = 0x80DB;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_BLUE_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_BLUE_SIZE = 0x80DC;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_ALPHA_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_ALPHA_SIZE = 0x80DD;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_LUMINANCE_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_LUMINANCE_SIZE = 0x80DE;

		/// <summary>
		/// [GL] Value of GL_COLOR_TABLE_INTENSITY_SIZE symbol.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_SGI_color_table")]
		public const int COLOR_TABLE_INTENSITY_SIZE = 0x80DF;

		/// <summary>
		/// [GL2.1] Gl.ConvolutionParameter: The image resulting from convolution is the same size as the source image, and 
		/// processed as if the source image were surrounded by pixels with their color specified by the 
		/// Gl.CONVOLUTION_BORDER_COLOR.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_HP_convolution_border_modes")]
		public const int CONSTANT_BORDER = 0x8151;

		/// <summary>
		/// [GL2.1] Gl.ConvolutionParameter: The image resulting from convolution is the same size as the source image, and 
		/// processed as if the outermost pixel on the border of the source image were replicated.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_HP_convolution_border_modes")]
		public const int REPLICATE_BORDER = 0x8153;

		/// <summary>
		/// [GL2.1] Gl.GetConvolutionParameter: The current convolution border color. params must be a pointer to an array of four 
		/// elements, which will receive the red, green, blue, and alpha border colors.
		/// </summary>
		[RequiredByFeature("GL_ARB_imaging", Api = "gl|glcore")]
		[RequiredByFeature("GL_HP_convolution_border_modes")]
		public const int CONVOLUTION_BORDER_COLOR = 0x8154;

		/// <summary>
		/// [GL2.1] glColorTable: define a color lookup table
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, Gl.POST_COLOR_MATRIX_COLOR_TABLE, Gl.PROXY_COLOR_TABLE, 
		/// Gl.PROXY_POST_CONVOLUTION_COLOR_TABLE, or Gl.PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the color table. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, Gl.ALPHA12, Gl.ALPHA16, 
		/// Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, Gl.LUMINANCE4_ALPHA4, 
		/// Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, Gl.LUMINANCE16_ALPHA16, 
		/// Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, Gl.RGB4, Gl.RGB5, 
		/// Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, Gl.RGBA12, and 
		/// Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The number of entries in the color lookup table specified by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. The allowable values are Gl.UNSIGNED_BYTE, Gl.BYTE, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		[RequiredByFeature("GL_SGI_color_table")]
		public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr data)
		{
			Debug.Assert(Delegates.pglColorTable != null, "pglColorTable not implemented");
			Delegates.pglColorTable((int)target, (int)internalformat, width, (int)format, (int)type, data);
			LogCommand("glColorTable", null, target, internalformat, width, format, type, data			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glColorTable: define a color lookup table
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, Gl.POST_COLOR_MATRIX_COLOR_TABLE, Gl.PROXY_COLOR_TABLE, 
		/// Gl.PROXY_POST_CONVOLUTION_COLOR_TABLE, or Gl.PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the color table. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, Gl.ALPHA12, Gl.ALPHA16, 
		/// Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, Gl.LUMINANCE4_ALPHA4, 
		/// Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, Gl.LUMINANCE16_ALPHA16, 
		/// Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, Gl.RGB4, Gl.RGB5, 
		/// Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, Gl.RGBA12, and 
		/// Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The number of entries in the color lookup table specified by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. The allowable values are Gl.UNSIGNED_BYTE, Gl.BYTE, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		[RequiredByFeature("GL_SGI_color_table")]
		public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, object data)
		{
			GCHandle pin_table = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				ColorTable(target, internalformat, width, format, type, pin_table.AddrOfPinnedObject());
			} finally {
				pin_table.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glColorTableParameterfv: set color lookup table parameters
		/// </summary>
		/// <param name="target">
		/// The target color table. Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="pname">
		/// The symbolic name of a texture color lookup table parameter. Must be one of Gl.COLOR_TABLE_SCALE or Gl.COLOR_TABLE_BIAS.
		/// </param>
		/// <param name="params">
		/// A pointer to an array where the values of the parameters are stored.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_SGI_color_table")]
		public static void ColorTableParameter(ColorTableTarget target, ColorTableParameterPName pname, float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglColorTableParameterfv != null, "pglColorTableParameterfv not implemented");
					Delegates.pglColorTableParameterfv((int)target, (int)pname, p_params);
					LogCommand("glColorTableParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glColorTableParameteriv: set color lookup table parameters
		/// </summary>
		/// <param name="target">
		/// The target color table. Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="pname">
		/// The symbolic name of a texture color lookup table parameter. Must be one of Gl.COLOR_TABLE_SCALE or Gl.COLOR_TABLE_BIAS.
		/// </param>
		/// <param name="params">
		/// A pointer to an array where the values of the parameters are stored.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_SGI_color_table")]
		public static void ColorTableParameter(ColorTableTarget target, ColorTableParameterPName pname, int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglColorTableParameteriv != null, "pglColorTableParameteriv not implemented");
					Delegates.pglColorTableParameteriv((int)target, (int)pname, p_params);
					LogCommand("glColorTableParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glCopyColorTable: copy pixels into a color table
		/// </summary>
		/// <param name="target">
		/// The color table target. Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="internalformat">
		/// The internal storage format of the texture image. Must be one of the following symbolic constants: Gl.ALPHA, Gl.ALPHA4, 
		/// Gl.ALPHA8, Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, 
		/// Gl.LUMINANCE_ALPHA, Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, 
		/// Gl.LUMINANCE12_ALPHA12, Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, 
		/// Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, 
		/// Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="x">
		/// The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
		/// </param>
		/// <param name="y">
		/// The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
		/// </param>
		/// <param name="width">
		/// The width of the pixel rectangle.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_SGI_color_table")]
		public static void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width)
		{
			Debug.Assert(Delegates.pglCopyColorTable != null, "pglCopyColorTable not implemented");
			Delegates.pglCopyColorTable((int)target, (int)internalformat, x, y, width);
			LogCommand("glCopyColorTable", null, target, internalformat, x, y, width			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetColorTable: retrieve contents of a color lookup table
		/// </summary>
		/// <param name="target">
		/// Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="table"/>. The possible values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="table"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="table">
		/// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, IntPtr table)
		{
			Debug.Assert(Delegates.pglGetColorTable != null, "pglGetColorTable not implemented");
			Delegates.pglGetColorTable((int)target, (int)format, (int)type, table);
			LogCommand("glGetColorTable", null, target, format, type, table			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetColorTable: retrieve contents of a color lookup table
		/// </summary>
		/// <param name="target">
		/// Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="table"/>. The possible values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="table"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="table">
		/// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, object table)
		{
			GCHandle pin_table = GCHandle.Alloc(table, GCHandleType.Pinned);
			try {
				GetColorTable(target, format, type, pin_table.AddrOfPinnedObject());
			} finally {
				pin_table.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glGetColorTableParameterfv: get color lookup table parameters
		/// </summary>
		/// <param name="target">
		/// The target color table. Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, Gl.POST_COLOR_MATRIX_COLOR_TABLE, 
		/// Gl.PROXY_COLOR_TABLE, Gl.PROXY_POST_CONVOLUTION_COLOR_TABLE, or Gl.PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="pname">
		/// The symbolic name of a color lookup table parameter. Must be one of Gl.COLOR_TABLE_BIAS, Gl.COLOR_TABLE_SCALE, 
		/// Gl.COLOR_TABLE_FORMAT, Gl.COLOR_TABLE_WIDTH, Gl.COLOR_TABLE_RED_SIZE, Gl.COLOR_TABLE_GREEN_SIZE, 
		/// Gl.COLOR_TABLE_BLUE_SIZE, Gl.COLOR_TABLE_ALPHA_SIZE, Gl.COLOR_TABLE_LUMINANCE_SIZE, or Gl.COLOR_TABLE_INTENSITY_SIZE.
		/// </param>
		/// <param name="params">
		/// A pointer to an array where the values of the parameter will be stored.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		public static void GetColorTableParameter(ColorTableTarget target, GetColorTableParameterPNameSGI pname, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetColorTableParameterfv != null, "pglGetColorTableParameterfv not implemented");
					Delegates.pglGetColorTableParameterfv((int)target, (int)pname, p_params);
					LogCommand("glGetColorTableParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetColorTableParameteriv: get color lookup table parameters
		/// </summary>
		/// <param name="target">
		/// The target color table. Must be Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, Gl.POST_COLOR_MATRIX_COLOR_TABLE, 
		/// Gl.PROXY_COLOR_TABLE, Gl.PROXY_POST_CONVOLUTION_COLOR_TABLE, or Gl.PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="pname">
		/// The symbolic name of a color lookup table parameter. Must be one of Gl.COLOR_TABLE_BIAS, Gl.COLOR_TABLE_SCALE, 
		/// Gl.COLOR_TABLE_FORMAT, Gl.COLOR_TABLE_WIDTH, Gl.COLOR_TABLE_RED_SIZE, Gl.COLOR_TABLE_GREEN_SIZE, 
		/// Gl.COLOR_TABLE_BLUE_SIZE, Gl.COLOR_TABLE_ALPHA_SIZE, Gl.COLOR_TABLE_LUMINANCE_SIZE, or Gl.COLOR_TABLE_INTENSITY_SIZE.
		/// </param>
		/// <param name="params">
		/// A pointer to an array where the values of the parameter will be stored.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_paletted_texture")]
		public static void GetColorTableParameter(ColorTableTarget target, GetColorTableParameterPNameSGI pname, [Out] int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetColorTableParameteriv != null, "pglGetColorTableParameteriv not implemented");
					Delegates.pglGetColorTableParameteriv((int)target, (int)pname, p_params);
					LogCommand("glGetColorTableParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glColorSubTable: respecify a portion of a color table
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="start">
		/// The starting index of the portion of the color table to be replaced.
		/// </param>
		/// <param name="count">
		/// The number of table entries to replace.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. The allowable values are Gl.UNSIGNED_BYTE, Gl.BYTE, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_color_subtable")]
		public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, IntPtr data)
		{
			Debug.Assert(Delegates.pglColorSubTable != null, "pglColorSubTable not implemented");
			Delegates.pglColorSubTable((int)target, start, count, (int)format, (int)type, data);
			LogCommand("glColorSubTable", null, target, start, count, format, type, data			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glColorSubTable: respecify a portion of a color table
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="start">
		/// The starting index of the portion of the color table to be replaced.
		/// </param>
		/// <param name="count">
		/// The number of table entries to replace.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.LUMINANCE, Gl.LUMINANCE_ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, and Gl.BGRA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. The allowable values are Gl.UNSIGNED_BYTE, Gl.BYTE, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_color_subtable")]
		public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, object data)
		{
			GCHandle pin_data = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				ColorSubTable(target, start, count, format, type, pin_data.AddrOfPinnedObject());
			} finally {
				pin_data.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glCopyColorSubTable: respecify a portion of a color table
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.COLOR_TABLE, Gl.POST_CONVOLUTION_COLOR_TABLE, or Gl.POST_COLOR_MATRIX_COLOR_TABLE.
		/// </param>
		/// <param name="start">
		/// The starting index of the portion of the color table to be replaced.
		/// </param>
		/// <param name="x">
		/// The window coordinates of the left corner of the row of pixels to be copied.
		/// </param>
		/// <param name="y">
		/// The window coordinates of the left corner of the row of pixels to be copied.
		/// </param>
		/// <param name="width">
		/// The number of table entries to replace.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_color_subtable")]
		public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width)
		{
			Debug.Assert(Delegates.pglCopyColorSubTable != null, "pglCopyColorSubTable not implemented");
			Delegates.pglCopyColorSubTable((int)target, start, x, y, width);
			LogCommand("glCopyColorSubTable", null, target, start, x, y, width			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionFilter1D: define a one-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_1D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.ALPHA, Gl.LUMINANCE, 
		/// Gl.LUMINANCE_ALPHA, Gl.INTENSITY, Gl.RGB, and Gl.RGBA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr data)
		{
			Debug.Assert(Delegates.pglConvolutionFilter1D != null, "pglConvolutionFilter1D not implemented");
			Delegates.pglConvolutionFilter1D((int)target, (int)internalformat, width, (int)format, (int)type, data);
			LogCommand("glConvolutionFilter1D", null, target, internalformat, width, format, type, data			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionFilter1D: define a one-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_1D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.ALPHA, Gl.LUMINANCE, 
		/// Gl.LUMINANCE_ALPHA, Gl.INTENSITY, Gl.RGB, and Gl.RGBA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="data">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, object data)
		{
			GCHandle pin_image = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				ConvolutionFilter1D(target, internalformat, width, format, type, pin_image.AddrOfPinnedObject());
			} finally {
				pin_image.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glConvolutionFilter2D: define a two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_2D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="height">
		/// The height of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, and Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="data">
		/// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr data)
		{
			Debug.Assert(Delegates.pglConvolutionFilter2D != null, "pglConvolutionFilter2D not implemented");
			Delegates.pglConvolutionFilter2D((int)target, (int)internalformat, width, height, (int)format, (int)type, data);
			LogCommand("glConvolutionFilter2D", null, target, internalformat, width, height, format, type, data			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionFilter2D: define a two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_2D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="height">
		/// The height of the pixel array referenced by <paramref name="data"/>.
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="data"/>. The allowable values are Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, and Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="data"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="data">
		/// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, object data)
		{
			GCHandle pin_image = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				ConvolutionFilter2D(target, internalformat, width, height, format, type, pin_image.AddrOfPinnedObject());
			} finally {
				pin_image.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glConvolutionParameterf: set convolution parameters
		/// </summary>
		/// <param name="target">
		/// The target for the convolution parameter. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be set. Must be Gl.CONVOLUTION_BORDER_MODE.
		/// </param>
		/// <param name="params">
		/// The parameter value. Must be one of Gl.REDUCE, Gl.CONSTANT_BORDER, Gl.REPLICATE_BORDER.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, float @params)
		{
			Debug.Assert(Delegates.pglConvolutionParameterf != null, "pglConvolutionParameterf not implemented");
			Delegates.pglConvolutionParameterf((int)target, (int)pname, @params);
			LogCommand("glConvolutionParameterf", null, target, pname, @params			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionParameterfv: set convolution parameters
		/// </summary>
		/// <param name="target">
		/// The target for the convolution parameter. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be set. Must be Gl.CONVOLUTION_BORDER_MODE.
		/// </param>
		/// <param name="params">
		/// The parameter value. Must be one of Gl.REDUCE, Gl.CONSTANT_BORDER, Gl.REPLICATE_BORDER.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglConvolutionParameterfv != null, "pglConvolutionParameterfv not implemented");
					Delegates.pglConvolutionParameterfv((int)target, (int)pname, p_params);
					LogCommand("glConvolutionParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionParameteri: set convolution parameters
		/// </summary>
		/// <param name="target">
		/// The target for the convolution parameter. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be set. Must be Gl.CONVOLUTION_BORDER_MODE.
		/// </param>
		/// <param name="params">
		/// The parameter value. Must be one of Gl.REDUCE, Gl.CONSTANT_BORDER, Gl.REPLICATE_BORDER.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, int @params)
		{
			Debug.Assert(Delegates.pglConvolutionParameteri != null, "pglConvolutionParameteri not implemented");
			Delegates.pglConvolutionParameteri((int)target, (int)pname, @params);
			LogCommand("glConvolutionParameteri", null, target, pname, @params			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glConvolutionParameteriv: set convolution parameters
		/// </summary>
		/// <param name="target">
		/// The target for the convolution parameter. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be set. Must be Gl.CONVOLUTION_BORDER_MODE.
		/// </param>
		/// <param name="params">
		/// The parameter value. Must be one of Gl.REDUCE, Gl.CONSTANT_BORDER, Gl.REPLICATE_BORDER.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void ConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglConvolutionParameteriv != null, "pglConvolutionParameteriv not implemented");
					Delegates.pglConvolutionParameteriv((int)target, (int)pname, p_params);
					LogCommand("glConvolutionParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glCopyConvolutionFilter1D: copy pixels into a one-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_1D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="x">
		/// The window space coordinates of the lower-left coordinate of the pixel array to copy.
		/// </param>
		/// <param name="y">
		/// The window space coordinates of the lower-left coordinate of the pixel array to copy.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array to copy.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width)
		{
			Debug.Assert(Delegates.pglCopyConvolutionFilter1D != null, "pglCopyConvolutionFilter1D not implemented");
			Delegates.pglCopyConvolutionFilter1D((int)target, (int)internalformat, x, y, width);
			LogCommand("glCopyConvolutionFilter1D", null, target, internalformat, x, y, width			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glCopyConvolutionFilter2D: copy pixels into a two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.CONVOLUTION_2D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="x">
		/// The window space coordinates of the lower-left coordinate of the pixel array to copy.
		/// </param>
		/// <param name="y">
		/// The window space coordinates of the lower-left coordinate of the pixel array to copy.
		/// </param>
		/// <param name="width">
		/// The width of the pixel array to copy.
		/// </param>
		/// <param name="height">
		/// The height of the pixel array to copy.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height)
		{
			Debug.Assert(Delegates.pglCopyConvolutionFilter2D != null, "pglCopyConvolutionFilter2D not implemented");
			Delegates.pglCopyConvolutionFilter2D((int)target, (int)internalformat, x, y, width, height);
			LogCommand("glCopyConvolutionFilter2D", null, target, internalformat, x, y, width, height			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetConvolutionFilter: get current 1D or 2D convolution filter kernel
		/// </summary>
		/// <param name="target">
		/// The filter to be retrieved. Must be one of Gl.CONVOLUTION_1D or Gl.CONVOLUTION_2D.
		/// </param>
		/// <param name="format">
		/// Format of the output image. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, 
		/// Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// Data type of components in the output image. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, Gl.UNSIGNED_SHORT, 
		/// Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="image">
		/// Pointer to storage for the output image.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, IntPtr image)
		{
			Debug.Assert(Delegates.pglGetConvolutionFilter != null, "pglGetConvolutionFilter not implemented");
			Delegates.pglGetConvolutionFilter((int)target, (int)format, (int)type, image);
			LogCommand("glGetConvolutionFilter", null, target, format, type, image			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetConvolutionFilter: get current 1D or 2D convolution filter kernel
		/// </summary>
		/// <param name="target">
		/// The filter to be retrieved. Must be one of Gl.CONVOLUTION_1D or Gl.CONVOLUTION_2D.
		/// </param>
		/// <param name="format">
		/// Format of the output image. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, 
		/// Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// Data type of components in the output image. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, Gl.UNSIGNED_SHORT, 
		/// Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="image">
		/// Pointer to storage for the output image.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, object image)
		{
			GCHandle pin_image = GCHandle.Alloc(image, GCHandleType.Pinned);
			try {
				GetConvolutionFilter(target, format, type, pin_image.AddrOfPinnedObject());
			} finally {
				pin_image.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glGetConvolutionParameterfv: get convolution parameters
		/// </summary>
		/// <param name="target">
		/// The filter whose parameters are to be retrieved. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or 
		/// Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be retrieved. Must be one of Gl.CONVOLUTION_BORDER_MODE, Gl.CONVOLUTION_BORDER_COLOR, 
		/// Gl.CONVOLUTION_FILTER_SCALE, Gl.CONVOLUTION_FILTER_BIAS, Gl.CONVOLUTION_FORMAT, Gl.CONVOLUTION_WIDTH, 
		/// Gl.CONVOLUTION_HEIGHT, Gl.MAX_CONVOLUTION_WIDTH, or Gl.MAX_CONVOLUTION_HEIGHT.
		/// </param>
		/// <param name="params">
		/// Pointer to storage for the parameters to be retrieved.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetConvolutionParameterfv != null, "pglGetConvolutionParameterfv not implemented");
					Delegates.pglGetConvolutionParameterfv((int)target, (int)pname, p_params);
					LogCommand("glGetConvolutionParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetConvolutionParameteriv: get convolution parameters
		/// </summary>
		/// <param name="target">
		/// The filter whose parameters are to be retrieved. Must be one of Gl.CONVOLUTION_1D, Gl.CONVOLUTION_2D, or 
		/// Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="pname">
		/// The parameter to be retrieved. Must be one of Gl.CONVOLUTION_BORDER_MODE, Gl.CONVOLUTION_BORDER_COLOR, 
		/// Gl.CONVOLUTION_FILTER_SCALE, Gl.CONVOLUTION_FILTER_BIAS, Gl.CONVOLUTION_FORMAT, Gl.CONVOLUTION_WIDTH, 
		/// Gl.CONVOLUTION_HEIGHT, Gl.MAX_CONVOLUTION_WIDTH, or Gl.MAX_CONVOLUTION_HEIGHT.
		/// </param>
		/// <param name="params">
		/// Pointer to storage for the parameters to be retrieved.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetConvolutionParameter(ConvolutionTarget target, ConvolutionParameterEXT pname, [Out] int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetConvolutionParameteriv != null, "pglGetConvolutionParameteriv not implemented");
					Delegates.pglGetConvolutionParameteriv((int)target, (int)pname, p_params);
					LogCommand("glGetConvolutionParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetSeparableFilter: get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// The separable filter to be retrieved. Must be Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="format">
		/// Format of the output images. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGRGl.RGBA, Gl.BGRA, 
		/// Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// Data type of components in the output images. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="row">
		/// Pointer to storage for the row filter image.
		/// </param>
		/// <param name="column">
		/// Pointer to storage for the column filter image.
		/// </param>
		/// <param name="span">
		/// Pointer to storage for the span filter image (currently unused).
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetSeparableFilter(SeparableTarget target, PixelFormat format, PixelType type, IntPtr row, IntPtr column, IntPtr span)
		{
			Debug.Assert(Delegates.pglGetSeparableFilter != null, "pglGetSeparableFilter not implemented");
			Delegates.pglGetSeparableFilter((int)target, (int)format, (int)type, row, column, span);
			LogCommand("glGetSeparableFilter", null, target, format, type, row, column, span			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetSeparableFilter: get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// The separable filter to be retrieved. Must be Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="format">
		/// Format of the output images. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGRGl.RGBA, Gl.BGRA, 
		/// Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// Data type of components in the output images. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="row">
		/// Pointer to storage for the row filter image.
		/// </param>
		/// <param name="column">
		/// Pointer to storage for the column filter image.
		/// </param>
		/// <param name="span">
		/// Pointer to storage for the span filter image (currently unused).
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetSeparableFilter(SeparableTarget target, PixelFormat format, PixelType type, object row, object column, object span)
		{
			GCHandle pin_row = GCHandle.Alloc(row, GCHandleType.Pinned);
			GCHandle pin_column = GCHandle.Alloc(column, GCHandleType.Pinned);
			GCHandle pin_span = GCHandle.Alloc(span, GCHandleType.Pinned);
			try {
				GetSeparableFilter(target, format, type, pin_row.AddrOfPinnedObject(), pin_column.AddrOfPinnedObject(), pin_span.AddrOfPinnedObject());
			} finally {
				pin_row.Free();
				pin_column.Free();
				pin_span.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glSeparableFilter2D: define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The number of elements in the pixel array referenced by <paramref name="row"/>. (This is the width of the separable 
		/// filter kernel.)
		/// </param>
		/// <param name="height">
		/// The number of elements in the pixel array referenced by <paramref name="column"/>. (This is the height of the separable 
		/// filter kernel.)
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="row"/> and <paramref name="column"/>. The allowable values are Gl.RED, 
		/// Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.INTENSITY, Gl.LUMINANCE, and Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="row"/> and <paramref name="column"/>. Symbolic constants Gl.UNSIGNED_BYTE, 
		/// Gl.BYTE, Gl.BITMAP, Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, 
		/// Gl.UNSIGNED_BYTE_2_3_3_REV, Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, 
		/// Gl.UNSIGNED_SHORT_4_4_4_4_REV, Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, 
		/// Gl.UNSIGNED_INT_8_8_8_8_REV, Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="row">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </param>
		/// <param name="column">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void SeparableFilter2D(SeparableTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr row, IntPtr column)
		{
			Debug.Assert(Delegates.pglSeparableFilter2D != null, "pglSeparableFilter2D not implemented");
			Delegates.pglSeparableFilter2D((int)target, (int)internalformat, width, height, (int)format, (int)type, row, column);
			LogCommand("glSeparableFilter2D", null, target, internalformat, width, height, format, type, row, column			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glSeparableFilter2D: define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// Must be Gl.SEPARABLE_2D.
		/// </param>
		/// <param name="internalformat">
		/// The internal format of the convolution filter kernel. The allowable values are Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, 
		/// Gl.ALPHA12, Gl.ALPHA16, Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, 
		/// Gl.LUMINANCE4_ALPHA4, Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, 
		/// Gl.LUMINANCE16_ALPHA16, Gl.INTENSITY, Gl.INTENSITY4, Gl.INTENSITY8, Gl.INTENSITY12, Gl.INTENSITY16, Gl.R3_G3_B2, Gl.RGB, 
		/// Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, Gl.RGBA8, Gl.RGB10_A2, 
		/// Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="width">
		/// The number of elements in the pixel array referenced by <paramref name="row"/>. (This is the width of the separable 
		/// filter kernel.)
		/// </param>
		/// <param name="height">
		/// The number of elements in the pixel array referenced by <paramref name="column"/>. (This is the height of the separable 
		/// filter kernel.)
		/// </param>
		/// <param name="format">
		/// The format of the pixel data in <paramref name="row"/> and <paramref name="column"/>. The allowable values are Gl.RED, 
		/// Gl.GREEN, Gl.BLUE, Gl.ALPHA, Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.INTENSITY, Gl.LUMINANCE, and Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of the pixel data in <paramref name="row"/> and <paramref name="column"/>. Symbolic constants Gl.UNSIGNED_BYTE, 
		/// Gl.BYTE, Gl.BITMAP, Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, 
		/// Gl.UNSIGNED_BYTE_2_3_3_REV, Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, 
		/// Gl.UNSIGNED_SHORT_4_4_4_4_REV, Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, 
		/// Gl.UNSIGNED_INT_8_8_8_8_REV, Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="row">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </param>
		/// <param name="column">
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_convolution")]
		public static void SeparableFilter2D(SeparableTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, object row, object column)
		{
			GCHandle pin_row = GCHandle.Alloc(row, GCHandleType.Pinned);
			GCHandle pin_column = GCHandle.Alloc(column, GCHandleType.Pinned);
			try {
				SeparableFilter2D(target, internalformat, width, height, format, type, pin_row.AddrOfPinnedObject(), pin_column.AddrOfPinnedObject());
			} finally {
				pin_row.Free();
				pin_column.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glGetHistogram: get histogram table
		/// </summary>
		/// <param name="target">
		/// Must be Gl.HISTOGRAM.
		/// </param>
		/// <param name="reset">
		/// If Gl.TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If 
		/// Gl.FALSE, none of the counters in the histogram table is modified.
		/// </param>
		/// <param name="format">
		/// The format of values to be returned in <paramref name="values"/>. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of values to be returned in <paramref name="values"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="values">
		/// A pointer to storage for the returned histogram table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetHistogram(HistogramTarget target, bool reset, PixelFormat format, PixelType type, IntPtr values)
		{
			Debug.Assert(Delegates.pglGetHistogram != null, "pglGetHistogram not implemented");
			Delegates.pglGetHistogram((int)target, reset, (int)format, (int)type, values);
			LogCommand("glGetHistogram", null, target, reset, format, type, values			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetHistogram: get histogram table
		/// </summary>
		/// <param name="target">
		/// Must be Gl.HISTOGRAM.
		/// </param>
		/// <param name="reset">
		/// If Gl.TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If 
		/// Gl.FALSE, none of the counters in the histogram table is modified.
		/// </param>
		/// <param name="format">
		/// The format of values to be returned in <paramref name="values"/>. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// The type of values to be returned in <paramref name="values"/>. Symbolic constants Gl.UNSIGNED_BYTE, Gl.BYTE, Gl.BITMAP, 
		/// Gl.UNSIGNED_SHORT, Gl.SHORT, Gl.UNSIGNED_INT, Gl.INT, Gl.FLOAT, Gl.UNSIGNED_BYTE_3_3_2, Gl.UNSIGNED_BYTE_2_3_3_REV, 
		/// Gl.UNSIGNED_SHORT_5_6_5, Gl.UNSIGNED_SHORT_5_6_5_REV, Gl.UNSIGNED_SHORT_4_4_4_4, Gl.UNSIGNED_SHORT_4_4_4_4_REV, 
		/// Gl.UNSIGNED_SHORT_5_5_5_1, Gl.UNSIGNED_SHORT_1_5_5_5_REV, Gl.UNSIGNED_INT_8_8_8_8, Gl.UNSIGNED_INT_8_8_8_8_REV, 
		/// Gl.UNSIGNED_INT_10_10_10_2, and Gl.UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </param>
		/// <param name="values">
		/// A pointer to storage for the returned histogram table.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetHistogram(HistogramTarget target, bool reset, PixelFormat format, PixelType type, object values)
		{
			GCHandle pin_values = GCHandle.Alloc(values, GCHandleType.Pinned);
			try {
				GetHistogram(target, reset, format, type, pin_values.AddrOfPinnedObject());
			} finally {
				pin_values.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glGetHistogramParameterfv: get histogram parameters
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.HISTOGRAM or Gl.PROXY_HISTOGRAM.
		/// </param>
		/// <param name="pname">
		/// The name of the parameter to be retrieved. Must be one of Gl.HISTOGRAM_WIDTH, Gl.HISTOGRAM_FORMAT, 
		/// Gl.HISTOGRAM_RED_SIZE, Gl.HISTOGRAM_GREEN_SIZE, Gl.HISTOGRAM_BLUE_SIZE, Gl.HISTOGRAM_ALPHA_SIZE, 
		/// Gl.HISTOGRAM_LUMINANCE_SIZE, or Gl.HISTOGRAM_SINK.
		/// </param>
		/// <param name="params">
		/// Pointer to storage for the returned values.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetHistogramParameter(HistogramTarget target, GetHistogramParameterPName pname, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetHistogramParameterfv != null, "pglGetHistogramParameterfv not implemented");
					Delegates.pglGetHistogramParameterfv((int)target, (int)pname, p_params);
					LogCommand("glGetHistogramParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetHistogramParameteriv: get histogram parameters
		/// </summary>
		/// <param name="target">
		/// Must be one of Gl.HISTOGRAM or Gl.PROXY_HISTOGRAM.
		/// </param>
		/// <param name="pname">
		/// The name of the parameter to be retrieved. Must be one of Gl.HISTOGRAM_WIDTH, Gl.HISTOGRAM_FORMAT, 
		/// Gl.HISTOGRAM_RED_SIZE, Gl.HISTOGRAM_GREEN_SIZE, Gl.HISTOGRAM_BLUE_SIZE, Gl.HISTOGRAM_ALPHA_SIZE, 
		/// Gl.HISTOGRAM_LUMINANCE_SIZE, or Gl.HISTOGRAM_SINK.
		/// </param>
		/// <param name="params">
		/// Pointer to storage for the returned values.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetHistogramParameter(HistogramTarget target, GetHistogramParameterPName pname, [Out] int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetHistogramParameteriv != null, "pglGetHistogramParameteriv not implemented");
					Delegates.pglGetHistogramParameteriv((int)target, (int)pname, p_params);
					LogCommand("glGetHistogramParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetMinmax: get minimum and maximum pixel values
		/// </summary>
		/// <param name="target">
		/// Must be Gl.MINMAX.
		/// </param>
		/// <param name="reset">
		/// If Gl.TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries 
		/// are unaltered.) If Gl.FALSE, the minmax table is unaltered.
		/// </param>
		/// <param name="format">
		/// The format of the data to be returned in <paramref name="values"/>. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="values">
		/// A pointer to storage for the returned values.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetMinmax(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, IntPtr values)
		{
			Debug.Assert(Delegates.pglGetMinmax != null, "pglGetMinmax not implemented");
			Delegates.pglGetMinmax((int)target, reset, (int)format, (int)type, values);
			LogCommand("glGetMinmax", null, target, reset, format, type, values			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetMinmax: get minimum and maximum pixel values
		/// </summary>
		/// <param name="target">
		/// Must be Gl.MINMAX.
		/// </param>
		/// <param name="reset">
		/// If Gl.TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries 
		/// are unaltered.) If Gl.FALSE, the minmax table is unaltered.
		/// </param>
		/// <param name="format">
		/// The format of the data to be returned in <paramref name="values"/>. Must be one of Gl.RED, Gl.GREEN, Gl.BLUE, Gl.ALPHA, 
		/// Gl.RGB, Gl.BGR, Gl.RGBA, Gl.BGRA, Gl.LUMINANCE, or Gl.LUMINANCE_ALPHA.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PixelType"/>.
		/// </param>
		/// <param name="values">
		/// A pointer to storage for the returned values.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetMinmax(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, object values)
		{
			GCHandle pin_values = GCHandle.Alloc(values, GCHandleType.Pinned);
			try {
				GetMinmax(target, reset, format, type, pin_values.AddrOfPinnedObject());
			} finally {
				pin_values.Free();
			}
		}

		/// <summary>
		/// [GL2.1] glGetMinmaxParameterfv: get minmax parameters
		/// </summary>
		/// <param name="target">
		/// Must be Gl.MINMAX.
		/// </param>
		/// <param name="pname">
		/// The parameter to be retrieved. Must be one of Gl.MINMAX_FORMAT or Gl.MINMAX_SINK.
		/// </param>
		/// <param name="params">
		/// A pointer to storage for the retrieved parameters.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetMinmaxParameter(MinmaxTarget target, GetMinmaxParameterPName pname, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetMinmaxParameterfv != null, "pglGetMinmaxParameterfv not implemented");
					Delegates.pglGetMinmaxParameterfv((int)target, (int)pname, p_params);
					LogCommand("glGetMinmaxParameterfv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glGetMinmaxParameteriv: get minmax parameters
		/// </summary>
		/// <param name="target">
		/// Must be Gl.MINMAX.
		/// </param>
		/// <param name="pname">
		/// The parameter to be retrieved. Must be one of Gl.MINMAX_FORMAT or Gl.MINMAX_SINK.
		/// </param>
		/// <param name="params">
		/// A pointer to storage for the retrieved parameters.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		public static void GetMinmaxParameter(MinmaxTarget target, GetMinmaxParameterPName pname, [Out] int[] @params)
		{
			unsafe {
				fixed (int* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetMinmaxParameteriv != null, "pglGetMinmaxParameteriv not implemented");
					Delegates.pglGetMinmaxParameteriv((int)target, (int)pname, p_params);
					LogCommand("glGetMinmaxParameteriv", null, target, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glHistogram: define histogram table
		/// </summary>
		/// <param name="target">
		/// The histogram whose parameters are to be set. Must be one of Gl.HISTOGRAM or Gl.PROXY_HISTOGRAM.
		/// </param>
		/// <param name="width">
		/// The number of entries in the histogram table. Must be a power of 2.
		/// </param>
		/// <param name="internalformat">
		/// The format of entries in the histogram table. Must be one of Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, Gl.ALPHA12, Gl.ALPHA16, 
		/// Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, Gl.LUMINANCE4_ALPHA4, 
		/// Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, Gl.LUMINANCE16_ALPHA16, 
		/// Gl.R3_G3_B2, Gl.RGB, Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, 
		/// Gl.RGBA8, Gl.RGB10_A2, Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="sink">
		/// If Gl.TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If 
		/// Gl.FALSE, pixels will proceed to the minmax process after histogramming.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_histogram")]
		public static void Histogram(HistogramTarget target, int width, InternalFormat internalformat, bool sink)
		{
			Debug.Assert(Delegates.pglHistogram != null, "pglHistogram not implemented");
			Delegates.pglHistogram((int)target, width, (int)internalformat, sink);
			LogCommand("glHistogram", null, target, width, internalformat, sink			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glMinmax: define minmax table
		/// </summary>
		/// <param name="target">
		/// The minmax table whose parameters are to be set. Must be Gl.MINMAX.
		/// </param>
		/// <param name="internalformat">
		/// The format of entries in the minmax table. Must be one of Gl.ALPHA, Gl.ALPHA4, Gl.ALPHA8, Gl.ALPHA12, Gl.ALPHA16, 
		/// Gl.LUMINANCE, Gl.LUMINANCE4, Gl.LUMINANCE8, Gl.LUMINANCE12, Gl.LUMINANCE16, Gl.LUMINANCE_ALPHA, Gl.LUMINANCE4_ALPHA4, 
		/// Gl.LUMINANCE6_ALPHA2, Gl.LUMINANCE8_ALPHA8, Gl.LUMINANCE12_ALPHA4, Gl.LUMINANCE12_ALPHA12, Gl.LUMINANCE16_ALPHA16, 
		/// Gl.R3_G3_B2, Gl.RGB, Gl.RGB4, Gl.RGB5, Gl.RGB8, Gl.RGB10, Gl.RGB12, Gl.RGB16, Gl.RGBA, Gl.RGBA2, Gl.RGBA4, Gl.RGB5_A1, 
		/// Gl.RGBA8, Gl.RGB10_A2, Gl.RGBA12, or Gl.RGBA16.
		/// </param>
		/// <param name="sink">
		/// If Gl.TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If 
		/// Gl.FALSE, pixels will proceed to the final conversion process after minmax.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_histogram")]
		public static void Minmax(MinmaxTarget target, InternalFormat internalformat, bool sink)
		{
			Debug.Assert(Delegates.pglMinmax != null, "pglMinmax not implemented");
			Delegates.pglMinmax((int)target, (int)internalformat, sink);
			LogCommand("glMinmax", null, target, internalformat, sink			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glResetHistogram: reset histogram table entries to zero
		/// </summary>
		/// <param name="target">
		/// Must be Gl.HISTOGRAM.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_histogram")]
		public static void ResetHistogram(HistogramTarget target)
		{
			Debug.Assert(Delegates.pglResetHistogram != null, "pglResetHistogram not implemented");
			Delegates.pglResetHistogram((int)target);
			LogCommand("glResetHistogram", null, target			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL2.1] glResetMinmax: reset minmax table entries to initial values
		/// </summary>
		/// <param name="target">
		/// Must be Gl.MINMAX.
		/// </param>
		[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
		[RequiredByFeature("GL_EXT_histogram")]
		public static void ResetMinmax(MinmaxTarget target)
		{
			Debug.Assert(Delegates.pglResetMinmax != null, "pglResetMinmax not implemented");
			Delegates.pglResetMinmax((int)target);
			LogCommand("glResetMinmax", null, target			);
			DebugCheckErrors(null);
		}

		internal static unsafe partial class Delegates
		{
			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture")]
			[RequiredByFeature("GL_SGI_color_table")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glColorTable(int target, int internalformat, int width, int format, int type, IntPtr table);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture", EntryPoint = "glColorTableEXT")]
			[RequiredByFeature("GL_SGI_color_table", EntryPoint = "glColorTableSGI")]
			[ThreadStatic]
			internal static glColorTable pglColorTable;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glColorTableParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table", EntryPoint = "glColorTableParameterfvSGI")]
			[ThreadStatic]
			internal static glColorTableParameterfv pglColorTableParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glColorTableParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table", EntryPoint = "glColorTableParameterivSGI")]
			[ThreadStatic]
			internal static glColorTableParameteriv pglColorTableParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glCopyColorTable(int target, int internalformat, int x, int y, int width);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_SGI_color_table", EntryPoint = "glCopyColorTableSGI")]
			[ThreadStatic]
			internal static glCopyColorTable pglCopyColorTable;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetColorTable(int target, int format, int type, IntPtr table);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture", EntryPoint = "glGetColorTableEXT")]
			[ThreadStatic]
			internal static glGetColorTable pglGetColorTable;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetColorTableParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture", EntryPoint = "glGetColorTableParameterfvEXT")]
			[ThreadStatic]
			internal static glGetColorTableParameterfv pglGetColorTableParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetColorTableParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_paletted_texture", EntryPoint = "glGetColorTableParameterivEXT")]
			[ThreadStatic]
			internal static glGetColorTableParameteriv pglGetColorTableParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_color_subtable")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glColorSubTable(int target, int start, int count, int format, int type, IntPtr data);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_color_subtable", EntryPoint = "glColorSubTableEXT")]
			[ThreadStatic]
			internal static glColorSubTable pglColorSubTable;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_color_subtable")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glCopyColorSubTable(int target, int start, int x, int y, int width);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_color_subtable", EntryPoint = "glCopyColorSubTableEXT")]
			[ThreadStatic]
			internal static glCopyColorSubTable pglCopyColorSubTable;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, IntPtr image);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionFilter1DEXT")]
			[ThreadStatic]
			internal static glConvolutionFilter1D pglConvolutionFilter1D;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr image);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionFilter2DEXT")]
			[ThreadStatic]
			internal static glConvolutionFilter2D pglConvolutionFilter2D;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionParameterf(int target, int pname, float @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionParameterfEXT")]
			[ThreadStatic]
			internal static glConvolutionParameterf pglConvolutionParameterf;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionParameterfvEXT")]
			[ThreadStatic]
			internal static glConvolutionParameterfv pglConvolutionParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionParameteri(int target, int pname, int @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionParameteriEXT")]
			[ThreadStatic]
			internal static glConvolutionParameteri pglConvolutionParameteri;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glConvolutionParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glConvolutionParameterivEXT")]
			[ThreadStatic]
			internal static glConvolutionParameteriv pglConvolutionParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glCopyConvolutionFilter1DEXT")]
			[ThreadStatic]
			internal static glCopyConvolutionFilter1D pglCopyConvolutionFilter1D;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glCopyConvolutionFilter2DEXT")]
			[ThreadStatic]
			internal static glCopyConvolutionFilter2D pglCopyConvolutionFilter2D;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetConvolutionFilter(int target, int format, int type, IntPtr image);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetConvolutionFilter pglGetConvolutionFilter;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetConvolutionParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetConvolutionParameterfv pglGetConvolutionParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetConvolutionParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetConvolutionParameteriv pglGetConvolutionParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetSeparableFilter(int target, int format, int type, IntPtr row, IntPtr column, IntPtr span);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetSeparableFilter pglGetSeparableFilter;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr row, IntPtr column);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_convolution", EntryPoint = "glSeparableFilter2DEXT")]
			[ThreadStatic]
			internal static glSeparableFilter2D pglSeparableFilter2D;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetHistogram(int target, [MarshalAs(UnmanagedType.I1)] bool reset, int format, int type, IntPtr values);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetHistogram pglGetHistogram;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetHistogramParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetHistogramParameterfv pglGetHistogramParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetHistogramParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetHistogramParameteriv pglGetHistogramParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetMinmax(int target, [MarshalAs(UnmanagedType.I1)] bool reset, int format, int type, IntPtr values);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetMinmax pglGetMinmax;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetMinmaxParameterfv(int target, int pname, float* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetMinmaxParameterfv pglGetMinmaxParameterfv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glGetMinmaxParameteriv(int target, int pname, int* @params);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[ThreadStatic]
			internal static glGetMinmaxParameteriv pglGetMinmaxParameteriv;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glHistogram(int target, int width, int internalformat, [MarshalAs(UnmanagedType.I1)] bool sink);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram", EntryPoint = "glHistogramEXT")]
			[ThreadStatic]
			internal static glHistogram pglHistogram;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glMinmax(int target, int internalformat, [MarshalAs(UnmanagedType.I1)] bool sink);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram", EntryPoint = "glMinmaxEXT")]
			[ThreadStatic]
			internal static glMinmax pglMinmax;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glResetHistogram(int target);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram", EntryPoint = "glResetHistogramEXT")]
			[ThreadStatic]
			internal static glResetHistogram pglResetHistogram;

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram")]
			[SuppressUnmanagedCodeSecurity]
			internal delegate void glResetMinmax(int target);

			[RequiredByFeature("GL_ARB_imaging", Profile = "compatibility")]
			[RequiredByFeature("GL_EXT_histogram", EntryPoint = "glResetMinmaxEXT")]
			[ThreadStatic]
			internal static glResetMinmax pglResetMinmax;

		}
	}

}
